<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Book Content Display</title>
    <link rel="stylesheet" href="styles.css">
    <script src="script.js" defer></script>
    <style>
        body {
          /* background-image: url('background.png');
          background-repeat: no-repeat;
        background-attachment: fixed;
        background-size: cover;
        background-blend-mode: multiply; */
        background-color: #DDDDFFAA;
        }
    </style>
</head>

<body>
    <nav>
        <a href="index.html">返回主页</a>
        <button onclick="showSection('linux')">Linux基础</button>
        <button onclick="showSection('vasp')">VASP教程</button>
        <button onclick="showSection('ml')">机器学习</button>
    </nav>
    <div class="sidebar">
        <div id="linux" class="section">
            <button class="toggle" onclick="toggleChapters('linux')">Linux基础</button>
            <div class="chapters" id="linuxChapters" style="display: none;">
                <div class="chapter" onclick="toggleSubChapters('linuxCommandLine')">
                    <h3>1. Linux命令行操作</h3>
                    <ul id="linuxCommandLineSubChapters" style="display: none;">
                        <li onclick="showContent('linuxDirectory')">1.1 认识Linux目录</li>
                        <li onclick="showContent('linuxDirectoryOperation')">1.2 目录操作</li>
                        <li onclick="showContent('linuxFileOperation')">1.3 文件操作</li>
                        <li onclick="showContent('linuxViewFile')">1.4 查看文件</li>
                        <li onclick="showContent('linuxCompress')">1.5 压缩与解压缩</li>
                        <li onclick="showContent('linuxFilePermission')">1.6 文件权限管理</li>
                    </ul>
                </div>
                <div class="chapter" onclick="toggleSubChapters('linuxTextEditor')">
                    <h3>2. 文本编辑工具vi和vim</h3>
                    <ul id="linuxTextEditorSubChapters" style="display: none;">
                        <li onclick="showContent('linuxNano')">2.1 使用nano简单创建文件</li>
                        <li onclick="showContent('linuxViVim')">2.2 使用vi,vim创建文件</li>
                        <li onclick="showContent('linuxFindReplace')">2.3 查找与替换</li>
                        <li onclick="showContent('linuxRegex')">2.4 初窥正则表达式</li>
                    </ul>
                </div>
                <div class="chapter" onclick="toggleSubChapters('linuxAdvancedCommands')">
                    <h3>3. 高级Linux命令</h3>
                    <ul id="linuxAdvancedCommandsSubChapters" style="display: none;">
                        <li onclick="showContent('linuxWildcards')">3.1 通配符</li>
                        <li onclick="showContent('linuxGrep')">3.2 grep匹配字符串</li>
                        <li onclick="showContent('sec:sed文本替换')">3.3 sed文本替换</li>
                        <li onclick="showContent('sec:管道与重定向')">3.4 管道与重定向</li>
                        <li onclick="showContent('sec:简单for循环')">3.5 简单for循环</li>
                    </ul>
                </div>

                <div class="chapter" onclick="toggleSubChapters('Shell')">
                    <h3>4. Shell脚本基础</h3>
                    <ul id="ShellSubChapters" style="display: none;">
                        <li onclick="showContent('sec:第一个脚本')">4.1 第一个脚本</li>
                        <li onclick="showContent('sec:变量')">4.2 变量</li>
                        <li onclick="showContent('sec:输入')">4.3 输入</li>
                        <li onclick="showContent('sec:判断语句')">4.4 判断语句</li>
                        <li onclick="showContent('sec:case分支语句')">4.5 case分支语句</li>
                        <li onclick="showContent('sec:循环')">【NEW!!!!!】4.6 循环</li>
                        <li onclick="showContent('sec:循环控制')">【NEW!!!!!】4.7 循环控制</li>
                        <li onclick="showContent('sec:函数')">【NEW!!!!!】4.8 *函数</li>
                        <li onclick="showContent('sec:数组')">【NEW!!!!!】4.9 *数组</li>
                    </ul>
                </div>
            </div>
        </div>
        <div id="vasp" class="section">
            <button class="toggle" onclick="toggleChapters('vasp')">VASP教程</button>
            <div class="chapters" id="vaspChapters" style="display: none;">
                <div class="chapter" onclick="toggleSubChapters('band')">
                    <h3>能带计算</h3>
                    <ul id="bandSubChapters" style="display: none;">
                        <li onclick="showContent('sec:能带基础理论')">能带基础理论</li>
                        <li onclick="showContent('sec:VASP计算能带过程')">VASP计算能带过程</li>
                        <li onclick="showContent('sec:能带绘图与后处理')">能带绘图与后处理</li>
                        <li onclick="showContent('sec:HSE能带计算')">HSE能带计算</li>
                    </ul>
                </div>

                <div class="chapter" onclick="toggleSubChapters('phonons')">
                    <h3>声子谱计算</h3>
                    <ul id="phononsSubChapters" style="display: none;">
                        <li onclick="showContent('sec:什么是声子、声子谱')">什么是声子、声子谱</li>
                        <li onclick="showContent('sec:计算方法简介')">计算方法简介</li>
                        <li onclick="showContent('sec:计算软件PHONOPY')">计算软件PHONOPY</li>
                        <li onclick="showContent('sec:具体计算步骤')">具体计算步骤</li>
                        <li onclick="showContent('sec:声子谱分析')">声子谱分析</li>
                        <li onclick="showContent('sec:错误处理')">错误处理</li>
                    </ul>
                </div>
                
            </div>
        </div>
        <div id="ml" class="section">
            <button class="toggle" onclick="toggleChapters('ml')">机器学习</button>
            <div class="chapters" id="mlChapters" style="display: none;">
                <!-- 机器学习章节内容 -->
            </div>
        </div>
    </div>
    <div class="content">
        <div id="linuxDirectory" class="chapter-content" style="display: none;">
            <h2>1.1 认识Linux目录</h2>
            <!-- <h1 id="sec:认识Linux目录">认识Linux目录</h1> -->
            <p><strong>作者：</strong>Jiaqi Z.</p>
            <h3>知识点</h3>
            <ul>
                <li>Linux命令格式</li>
                <li>如何在Linux当中表示目录</li>
                <li>绝对路径和相对路径</li>
                <li>如何快速表示当前目录和上一级目录</li>
            </ul>
        
            <h3 id="subsec:认识Linux目录-命令格式">命令格式</h3>
            <p>与Windows使用可视化界面不同，Linux大多时候使用命令行（shell）进行操作。因此，在Linux的学习过程中，一个最重要的任务，就是掌握一些常见的Linux命令。对于大多数科研课题组而言，Linux系统都是在远程云端服务器上，因此在本地往往只需要一个终端程序即可连接到服务器。一些常见的终端软件包括Xshell、MobaXterm、甚至VS Code<sup>1</sup>等。</p>
            <div class="attention">
                <p>如果你熟悉其他操作系统，可能听闻过类似于Windows Server，或者Linux的Ubuntu这样的操作系统。明明也可以使用可视化界面，为什么在科研过程中从来不会用到它们呢？（更严谨地说，在远程服务器上）。实际上，当使用可视化界面进行远程连接时，所产生的网络资源消耗是巨大的，通常需要更大的带宽，而使用命令行就可以提高数据传输效率。此外，更重要的一点是，使用命令行可以很容易实现批量处理，这在后续的章节会介绍到。</p>
            </div>
        
            <p>在Linux当中，输入命令通常采用的格式是<code>命令 [-选项] [参数]</code>，其中中括号表示这个部分是<em>可选的</em>，即可以没有的。例如，当我们希望列出当前目录下所有文件时，可以使用<code>ls</code>直接输出，也可以使用<code>ls -l</code>以列表格式输出。</p>
            <div class="attention">
                <p>在后面可能会看到选项有多个的情况，此时为了简化，可以将选项合并在一起。例如，<code>ls -l -a</code>可以简化为<code>ls -la</code>。</p>
                <p>命令与选项、参数之间是以空格进行分割，且这个空格不能省略。</p>
            </div>
        
            <h3 id="subsec:认识Linux目录-目录表示方法">目录表示方法</h3>
            <p>在Linux当中，所有目录都是以根目录<code>/</code>为起点，任何目录都是根目录的子目录。根目录下存在一些固定的目录（这些目录通常有特定的含义），例如，在根目录下有一个叫做<code>bin</code>的目录（通常写作<code>/bin</code>），它存放的都是<em>二进制文件</em>，也就是系统可以执行的程序文件。</p>
            <div class="attention">
                <p>在Linux当中，任何命令实际上都是可执行程序。你可以在<code>/bin</code>目录下看到后面所学的所有Linux终端命令。</p>
            </div>
        
            <p>另一个比较重要的位置是家目录<code>/home</code>，它存放的是用户个人文件。在这一目录下，你可以看到系统所注册的所有用户名。但是，这些文件夹大多数是无法查看的<sup>2</sup>。对于用户自己的家目录，通常也可以表示为<code>~</code>。通常来说，当你使用终端等连接登录时，默认的所在目录就是家目录<code>~</code></p>
        
            <h3 id="subsec:认识Linux目录-绝对路径和相对路径">绝对路径和相对路径</h3>
            <p>任何目录在操作时都具有两种表示方式，<em>绝对路径</em>和<em>相对路径</em>。正如<em>目录表示方法</em>所介绍的那样，任何目录都是从根目录开始的。因此在描述一个目录时，可以从根目录（即<code>/</code>）开始。例如，若你在你的家目录下有一个叫做<code>vasp</code>的目录，那么它的绝对路径就是<code>/home/&lt;你的用户名&gt;/vasp</code>。</p>
            <div class="attention">
                <p>在这种情况下，你可以将目录<code>vasp</code>理解为<code>&lt;当前所在目录&gt;/vasp</code>，即等价于<code>/home/&lt;你的用户名&gt;/vasp</code>。</p>
                <p>千万不要写成<code>/vasp</code>，它表示根目录下的<code>vasp</code>目录。如果你希望特别强调当前目录，可以使用符号<code>.</code>（一个点）表示“当前目录”，即可以写成<code>./vasp</code></p>
            </div>
        
            <p>然而，在这种情况下，回到<em>当前目录的上一级目录</em>是麻烦的，即在目前所学范围内，只能使用绝对路径。好在Linux提供了一个命令：<code>..</code>（两个点）表示<em>上一级目录</em>。因此，如果你当前处在目录<code>/home/&lt;你的用户名&gt;/vasp</code>当中，则<code>..</code>表示<code>/home/&lt;你的用户名&gt;</code></p>
            <div class="attention">
                <p>在终端当中，<code>..</code>（两个点）表示父目录（即上一级目录），而一个点<code>.</code>表示当前目录。</p>
                <p>这些符号（指令）在后续关于目录操作中都是可以使用的。</p>
            </div>
        
            <p>看到这里，可以思考下面的问题：如果在你的家目录下有两个目录<code>python</code>和<code>vasp</code>，此时你在<code>/home/&lt;你的用户名&gt;/vasp</code>目录下，如何可以快速表示<code>python</code>目录呢（不能使用绝对路径）？</p>
            <p><strong>答案：</strong><code>../python</code>即可表示<code>/home/&lt;你的用户名&gt;/python</code>目录</p>
        
            <footer>
                <p>注解：</p>
                <ol>
                    <li id="ftnt1">对于VS Code而言，可能需要扩展插件（例如Remote-SSH）的支持。</li>
                    <li id="ftnt2">这涉及到Linux操作权限的问题，通常来说，权限分为三组，即所有者权限、所属组权限和其他用户权限。对于<code>/home</code>目录下而言，所有目录都是对所有者（即这个用户本身）提供全部权限，而其他人无法访问、修改。</li>
                </ol>
            </footer>
        </div>
        <div id="linuxDirectoryOperation" class="chapter-content" style="display: none;">
            <h2>1.2 目录操作</h2>
            <p><strong>作者：</strong>Jiaqi Z.</p>
    
    <h3>知识点</h3>
    <ul>
        <li>如何显示当前目录下所有文件</li>
        <li>如何创建目录</li>
        <li>如何切换至其他目录</li>
    </ul>

    <h3 id="subsec:目录操作-显示目录文件">显示目录文件 <code>ls</code></h3>
    <p>在这一节以及下一节，我们将讨论如何对目录和文件做基本的操作。无论是哪一种，一个最基本的前提是<strong>知道当前目录有哪些文件和目录</strong>，从而才能进行后续操作（例如编辑、删除、移动、进入目录等）。</p>

    <p>在Linux当中，列出一个目录下所有文件使用的是<code>ls</code>命令。在没有任何参数与选项的前提下，它输出的结果就是<strong>当前所在目录下的所有文件和目录</strong>。以<a href="#subsec:认识Linux目录-绝对路径和相对路径">绝对路径和相对路径</a>一节最后的例子为例，家目录下有<code>vasp</code>和<code>python</code>两个目录，当在家目录下执行<code>ls</code>命令时，结果如下：</p>

    <pre><code class="bash">$ ls
vasp  python
</code></pre>

    <p>同时，<code>ls</code>支持在后面添加一个参数表示要输出的目录。例如，在这一例子下，若在家目录当中执行命令<code>ls vasp</code>，将会输出<code>vasp</code>目录下的所有文件和目录。利用<code>..</code>表示上一级目录的用法，若当前处在<code>~/vasp</code>目录下，使用<code>ls ..</code>便可得到上一级目录（即家目录）下的所有文件和目录。</p>

    <h4><code>ls -l</code></h4>
    <p>下面介绍两个常见的<code>ls</code>选项，首先是<code>-l</code>选项，它表示<strong>以列表形式输出结果</strong>。例如，还是上面的例子，使用这一命令的结果为：</p>

    <pre><code class="bash">$ ls -l
total 0
drwxrwxr-x 2 zjq zjq 6 Aug 12 16:35 python
drwxrwxr-x 2 zjq zjq 6 Aug 12 16:35 vasp
</code></pre>

    <div class="extend">
        <p>每一个文件的输出结果可以分为9个部分，分别是：权限、文件硬链接数或目录子目录数、拥有者用户名、拥有者所在组、文件大小、文件修改月份、日期、时间、文件名。</p>
        <p>关于权限，可以将其分成四部分：第一部分（一个字符）表示文件类型（这里的<code>d</code>表示目录），第二部分（三个字符）表示拥有者权限（<code>rwx</code>表示可读可写可执行），第三部分（三个字符）表示组用户权限，第四部分（三个字符）表示其他用户权限（<code>r-x</code>）表示可读，可执行但不可编辑。</p>
        <p>对于文件硬链接数和目标子目录数，对于初始创建的文件而言，通常为1，而对于目录而言，默认为2（因为有两个子目录<code>.</code>和<code>..</code>）</p>
    </div>

    <p>有时，也可以使用<code>ll</code>代替指令<code>ls -l</code>，其二者是完全等价的。</p>

    <h4><code>ls -a</code></h4>
    <p><code>-a</code>选项表示<strong>列出所有文件，包括隐藏文件</strong>。例如，在<code>~/vasp</code>目录下，使用<code>ls -a</code>命令，结果为：</p>

    <pre><code class="bash">$ ls -a
.  ..
</code></pre>

    <div class="extend">
        <p>正如前面所介绍的那样，任何一个空目录都会默认有两个隐藏目录--自身和它的上一级目录。而这也解释了<a href="#subsec:认识Linux目录-绝对路径和相对路径">绝对路径和相对路径</a>一节所介绍的<code>.</code>和<code>..</code>的本质，它们实际上就是任何当前目录下的两个子目录。</p>
    </div>

    <div class="attention">
        <p>前面所介绍的<code>-l</code>选项和<code>-a</code>选项是可以合并使用的，此时可以将两个选项之间以空格分割，如<code>ls -l -a</code>，或者将两个选项写在一起<code>ls -la</code>。</p>
        <p>当选项写在一起时，选项的排列顺序不重要。</p>
        <p>与最开始介绍<code>ls</code>后面加参数表示目录一样，带有选项的<code>ls</code>同样可以在后面添加参数，例如，<code>ls -a vasp</code>表示列出当前目录下的<code>vasp</code>子目录下的所有文件和目录（包括隐藏文件）。</p>
    </div>

    <h3 id="subsec:目录操作-关于隐藏文件">关于隐藏文件</h3>
    <div class="extend">
        <p>隐藏文件是指在文件名前面加上<code>.</code>的，例如<code>.bashrc</code>。</p>
        <p>隐藏文件在Linux当中的常见用途有：</p>
        <ul>
            <li>配置文件</li>
            <li>临时文件</li>
            <li>缓存文件</li>
            <li>等</li>
        </ul>
        <p>总而言之，隐藏文件是为了防止误操作而存在的。（这可能与一些人认为的“隐藏文件是避免别人看到”不同）事实上，哪怕在Windows操作系统中，隐藏文件也是存在且方便查看的。</p>
    </div>

    <h3 id="subsec:目录操作-创建目录">创建目录 <code>mkdir</code></h3>
    <p>如果所有操作都在家目录下进行，那文件管理就太复杂了。试想一下，在科研里面算了好几年的结果，全部“一股脑”堆在一起，既难找，也容易忘记当时是做了什么。因此，一个好的目录管理至关重要。而前提，就是知道如何创建目录。</p>

    <p>在Linux当中，创建目录的方法是使用<code>mkdir</code>命令。与前面介绍的<code>ls</code>，以及后面要介绍的<code>cd</code>不同的是，<code>mkdir</code>必须带有一个参数，表示<strong>创建的目录路径</strong>。对于刚开始接触的初学者，一个最简单的命令格式是：<code>mkdir &lt;目录名&gt;</code>，其中表示在当前目录下创建一个名为<code>&lt;目录名&gt;</code>的目录。例如，希望在当前目录下创建一个名为<code>ML</code>的目录，则可以使用命令<code>mkdir ML</code>。</p>

    <div class="attention">
<p>你所写的路径名，应当是你所要创建的目录。这句话似乎有点绕，举个例子，如果你希望在<code>/home/zjq/vasp</code>下创建一个名为<code>lattice</code>的目录，则你需要运行的命令是<code>mkdir /home/zjq/vasp/lattice</code>。注意到，后面的路径实际上就是你要创建的目录。</p>
</div>

<h3 id="subsec:目录操作-切换目录">切换目录 <code>cd</code></h3>
<p>在Linux当中，切换目录使用的命令是<code>cd</code>，通常来说，后面需要配合一个参数，表示<strong>要切换到哪里</strong>。例如，使用命令<code>cd /home</code>则是将当前目录切换到<code>/home</code>目录下。配合以<code>..</code>，可以使用<code>cd ..</code>切换到上一级目录。</p>
<p><strong>思考：</strong>如果使用<code>cd .</code>，会得到什么结果？</p>
<p><strong>答案：</strong>这个命令的含义是<strong>切换到当前目录</strong>，最终效果就是什么也不发生。</p>
<p>特殊的，对于家目录而言，除了可以使用<code>cd ~</code>外，Linux也支持直接使用<code>cd</code>，不添加任何参数实现这一功能，即二者是等价的。</p>

<h3 id="subsec:目录操作-错误处理">错误处理</h3>
<h4>-bash: cd: &lt;目录名&gt;: Not a directory</h4>
<p><code>cd</code>后面的参数必须是目录，不能是文件。如果参数是文件，则会报该错误。</p>
<p>如果不知道哪个是目录，哪个是文件，可以使用<code>ls -l</code>查看第一个字符（文件类型），如果第一个字符是<code>d</code>，则表示目录，如果是<code>-</code>，则表示文件。</p>
<pre><code class="bash">$ ls -l
total 4
-rw-rw-r-- 1 zjq zjq 4 Aug 12 17:12 INCAR
drwxrwxr-x 2 zjq zjq 6 Aug 12 16:35 python
drwxrwxr-x 2 zjq zjq 6 Aug 12 16:35 vasp
</code></pre>
<p>表示<code>INCAR</code>是文件，而<code>vasp</code>和<code>python</code>是目录。如果执行了<code>cd INCAR</code>，则会报错。</p>

<h4>-bash: cd: &lt;目录名&gt;: No such file or directory</h4>

<p>这是因为你所要进入的目录不存在。请再次检查你所输入的目录是否正确。</p>

<h4>-bash: cd: &lt;目录名&gt;: Permission denied</h4>
<p>这表明你尝试进入一个你没有权限的目录。例如，在<code>/home</code>目录下，有<code>ljk</code>和<code>zjq</code>两个目录，分别表示两个用户。如果执行<code>ls -l</code>则会发现：</p>
<pre><code class="bash">$ ls -l
total 32
drwx------  13 ljk    ljk    4096 Aug  5 17:34 ljk
drwx------  75 zjq    zjq    4096 Aug 12 17:12 zjq
</code></pre>
<p>很显然，每个目录只有目录拥有者自己可以访问。例如，作为用户<code>zjq</code>，当尝试执行<code>cd ljk</code>时，则会报错。</p>

<div class="extend">
    <p>这种情况有一个特例：root用户。对于root用户而言，可以进入任何目录。但通常来说，root用户是由服务器管理者所持有的，作为一般用户而言，不需要也不应该进入没有权限的目录，或者执行没有权限的操作。</p>
</div>

<h4>mkdir: cannot create directory &lt;目录名&gt;: No such file or directory</h4>
<p>虽然我们说可以用绝对路径或相对路径在更远的层级关系下创建目录。但这一操作的前提是，<strong>这个目录的上一级目录需要存在</strong>。例如，当你执行<code>mkdir vasp/lattice/Fe</code>时，首先需要确保目录<code>vasp</code>和<code>vasp/lattice</code>存在，才会创建<code>vasp/lattice/Fe</code>。如果你要创建的目录其上一级目录不存在，则会报错。</p>
<p>一个很自然的解决方法是：<strong>一层一层创建</strong>。这种方法虽然麻烦，但可以确保目录是清晰的。</p>
<div class="extend">
    <p>如果你确实想要一个快捷的方法，可以使用选项<code>-p</code>。这一选项可以在遇到没有的目录时自动为你创建。例如，上面的例子也可以直接使用<code>mkdir -p vasp/lattice/Fe</code>，但这一操作需要保证输入内容是正确的。一旦有内容输错，则极有可能造成目录结构混乱。</p>
</div>

<h4>mkdir: missing operand</h4>
<p>很显然，你在使用<code>mkdir</code>时没有给任何参数。正如<a href="#subsec:目录操作-创建目录">创建目录</a>所说的那样，在调用<code>mkdir</code>时<strong>必须提供一个参数表示要创建的目录路径</strong>。</p>
        </div>
        <div id="linuxFileOperation" class="chapter-content" style="display: none;">
            <h2>1.3 文件操作</h2>
            <p><strong>作者：</strong>Jiaqi Z.</p>
    
    <h3>知识点</h3>
    <ul>
        <li>如何移动文件（目录），如何给文件（目录）重命名</li>
        <li>如何删除文件（目录）</li>
        <li>如何复制文件（目录）</li>
    </ul>

    <p>这一节，我们专注于文件的相关操作。类似于Windows的基本操作，Linux的文件操作也无外乎就是<strong>移动、删除、复制</strong>。同时，这一节的许多命令对于文件和目录都是适用的，但可能会有一个注意事项，这往往会出错。</p>

    <h3 id="subsec:文件操作-移动文件">移动文件 <code>mv</code></h3>
    <p>在Linux当中，移动文件使用的命令是<code>mv</code>。其基本用法是<code>mv &lt;源文件路径&gt; &lt;目标文件路径&gt;</code>。例如，我们在<code>vasp</code>目录下，希望将里面的<code>OUTCAR</code>移动至上一级目录，可以使用<code>mv OUTCAR ..</code>。类似地，对于更复杂的文件移动，只不过在描述路径时稍微复杂一点，其他的步骤没有什么不同。</p>
    <p>如果你足够敏感，也许会发现一点问题：<strong>为什么前面的命令，<code>OUTCAR</code>是文件，而<code>..</code>是目录</strong>？两个难道不应该统一吗？</p>
    <p>对于这个问题，可以分两个部分讨论：如果前面是文件，后面也是文件，例如<code>mv OUTCAR ../OUTCAR</code>，这个命令与前面的命令效果是完全等价的。但是，有趣的地方在于，如果你试着执行<code>mv OUTCAR ../INCAR</code>的话，你会发现，Linux将<code>OUTCAR</code>移动到<code>..</code>的同时，还将其改名为<code>INCAR</code>。</p>
    <p>进一步想一下，如果我们现在直接写成<code>mv OUTCAR INCAR</code>的话，可以将其看作把当前目录下的<code>OUTCAR</code>移动至当前目录，同时改名为<code>INCAR</code>，总的效果就是，文件被重命名为<code>INCAR</code>。</p>
    <div class="attention">
        <p>正如你所见到的那样，Linux没有单独的重命名文件命令，而是通过<code>mv</code>命令来完成。</p>
    </div>
    <p>进一步，如果前后两个参数都是目录会发生什么呢？很简单，<strong>就是将前面的目录移动至后面的目录</strong>，从效果上看，近似于将第一个参数的目录看作文件。</p>
    <div class="attention">
        <p>与文件移动类似的操作，如重命名，对目录的移动同样成立。</p>
    </div>

    <h3 id="subsec:文件操作-如何删除文件">如何删除文件 <code>rm</code></h3>
    <p>相比于移动文件需要两个参数，删除文件的命令<code>rm</code>只需要一个参数即可，也许你也能猜到这个参数的含义，即<code>rm &lt;删除的文件路径&gt;</code>。例如，要删除当前目录下的<code>INCAR</code>文件，只需要执行<code>rm INCAR</code>即可。同样的，你也可以使用更复杂的绝对路径或相对路径，例如，删除上一级目录下的<code>OUTCAR</code>文件，可以使用<code>rm ../OUTCAR</code>。</p>
    <div class="extend">
        <p>与Windows不同，Linux删除文件通常是直接删除，而不是放在所谓的<strong>回收站</strong>内。因此，在删除文件时务必小心。</p>
        <p>在有些版本的Linux（例如Ubuntu）当中，删除的文件被移动至<code>/home/&lt;用户名&gt;/.local/share/Trash/files</code>当中，这个目录起到的临时的<strong>回收站</strong>功能，但你不应该寄希望于这个功能，而是仔细检查删除文件的正确性，并做好合适的备份。</p>
    </div>
    <p>对于删除目录而言，情况有点特殊，需要使用<code>rm -r</code>命令删除一个目录，此时后面所接参数为目录的路径，例如，删除当前目录下的<code>vasp</code>目录，则可以使用<code>rm -r vasp</code>。</p>
    <div class="attention">
        <p><code>-r</code>选项通常表示<strong>递归</strong>，例如，在<code>rm -r</code>当中，表示<strong>递归删除</strong>，从而达到删除一个目录的效果。在删除目录时会连同里面的所有内容都删除掉，因此需要特别小心。</p>
        <p>如果担心删除错误的文件，可以在选项中使用<code>-i</code>。<code>rm -i</code>表示<strong>在删除时</strong>询问是否删除。</p>
        <p>对于空目录而言，Linux还提供了一个命令<code>rmdir</code>，其用法为<code>rmdir &lt;目录路径名&gt;</code>，可以删除一个<strong>空目录</strong>。</p>
    </div>

    <h3 id="subsec:文件操作-如何复制文件">如何复制文件 <code>cp</code></h3>
    <p>复制文件的命令为<code>cp</code>，其用法与移动文件<code>mv</code>几乎完全一样，无非就是将<strong>移动</strong>改为<strong>复制</strong>。简单来说，语法就是<code>cp &lt;源文件路径&gt; &lt;目标文件路径&gt;</code>，类似于<a href="#subsec:文件操作-移动文件">移动文件</a>当中所介绍的重命名方法，使用<code>cp</code>命令同样可以做到复制的同时重命名。例如，<code>cp vasp/OUTCAR ../INCAR</code>表示将<code>vasp</code>目录下的<code>OUTCAR</code>文件复制到上一层目录，并重命名为<code>INCAR</code></p>
    <p>如果想要复制一个目录，也需要使用选项<code>cp -r</code>。例如，<code>cp -r vasp/ python/</code>表示将<code>vasp</code>目录复制到当前目录并重命名为<code>python</code>。</p>
    <div class="attention">
        <p>我们在上面的命令当中使用<code>vasp/</code>和<code>python/</code>表示两个目录。其中使用了符号<code>/</code>作为结尾，这个符号通常强调该路径是个目录。对于Linux本身而言，有没有这个符号并没有区别。例如，<code>cp -r vasp python</code>也可以表示上面的操作。我们这么写只是为了强调这两个路径是目录而不是文件。</p>
    </div>

    <h3 id="subsec:文件操作-一次性处理多个文件">一次性处理多个文件</h3>
    <p>前面介绍的<code>rm</code>，<code>cp</code>，<code>mv</code>，以及在<a href="#sec:目录操作">目录操作</a>一节所介绍的<code>mkdir</code>，都是可以针对多个文件同时操作的。以<code>rm</code>为例，如果想同时删除多个文件，只需要在后面添加多个参数即可，其中参数之间以空格分割。例如，<code>rm INCAR KPOINTS</code>表示删除当前目录下的<code>INCAR</code>文件和<code>KPOINTS</code>文件。对于<code>mkdir</code>创建多个目录而言，也是一样的用法，例如，使用<code>mkdir vasp ML</code>表示在当前目录下创建<code>vasp</code>目录和<code>ML</code>目录。</p>
<p>对于<code>cp</code>和<code>mv</code>而言，情况稍有不同。它们自身就需要两个参数，第一个是源路径，第二个是目标路径。如果有多个文件需要处理，Linux默认<strong>最后一个路径为目标路径，前面的所有参数都是源路径</strong>。例如，<code>cp INCAR KPOINTS POSCAR POTCAR ..</code>表示将<code>INCAR</code>，<code>KPOINTS</code>，<code>POSCAR</code>和<code>POTCAR</code>复制到上一级目录中。</p>
<div class="attention">
<p>对于<code>cp</code>和<code>mv</code>而言，若一次性移动多个文件，则最后一个参数必须是目录。这就意味着不能进行重命名操作。</p>
</div>

<h3 id="subsec:文件操作-错误处理">错误处理</h3>
<h4>rmdir: failed to remove &lt;路径名&gt;: Directory not empty</h4>
<p>使用<code>rmdir</code>命令时，<strong>只能用来删除空目录</strong>。当要删除的目录不是空目录时，执行该命令则会报错。使用<code>rm -r &lt;路径名&gt;</code>往往是删除非空目录的常见方法。</p>

<h4>cp: -r not specified; omitting directory &lt;路径名&gt;</h4>
<p>当使用<code>cp</code>复制目录时，需要添加<code>-r</code>选项。如果没有添加这一选项则会报错。</p>

<h4>cp: target &lt;路径名&gt; is not a directory</h4>
<p>这通常出现在尝试使用<code>cp</code>复制多个文件时，最后的参数<strong>必须是目录</strong>。如果此时不是目录，则会报错。</p>

<h4>rm: cannot remove &lt;路径名&gt;: No such file or directory</h4>
<p>表明你正在使用<code>rm</code>命令删除一个不存在的文件。请仔细检查你的文件路径名是否正确。</p>

<h4>rm: cannot remove &lt;路径名&gt;: Is a directory</h4>
<p>类似于<code>cp</code>复制目录，使用<code>rm</code>删除目录时，也需要添加<code>-r</code>选项。特别地，对于一次性删除多个文件，如果在删除文件的同时也存在把目录删除的情况，也需要添加这一选项。</p>

<h4>rm: remove write-protected regular file &lt;文件名&gt;? </h4>
<p>当你尝试对没有权限（不可写）的文件进行删除时，会提示该错误。关于权限的内容，将在<a href="#sec:文件权限管理">文件权限管理</a>一节详细讨论。在Linux当中，是有方法对文件权限进行修改的，但这并不是一个明智的方法。仔细检查文件操作，遵守这些权限，不要“越界”，可以保证你“安全”地使用操作系统（不会引起系统崩溃等严重问题）。</p>
<p>如果你确实需要删除，则只需要输入<code>y</code>（表示“yes”）并回车即可；反之则输入<code>n</code>（表示“no”）。</p>
        </div>
        <div id="linuxViewFile" class="chapter-content" style="display: none;">
            <h2>1.4 查看文件</h2>
            <p><strong>作者：</strong>Jiaqi Z.</p>
    
    <h3>知识点</h3>
    <ul>
        <li>Linux文件类型</li>
        <li>如何查看Linux文件</li>
    </ul>

    <p>这一节看似知识点不多，但命令还是挺多的。因此，一节只讲这一部分内容完全足够了。</p>

    <h3 id="subsec:查看文件-Linux文件类型">Linux文件类型</h3>
    <div class="extend">
        <p>在<a href="#subsec:目录操作-显示目录文件">显示目录文件</a>当中，我们介绍了<code>ls -l</code>命令可以以列表形式查看文件。当时仅仅提到，第一个字符如果是<code>d</code>则表示<strong>目录</strong>，如果是<code>-</code>则表示<strong>普通文件</strong>。在这一部分，我们稍微详细介绍一下更多的文件类型。</p>
        <ul>
            <li>普通文件（<code>-</code>）：就是普通的文件，通常可以分为<strong>文本文件</strong>，<strong>可执行文件</strong>和<strong>压缩文件</strong>等；
            <li>目录（<code>d</code>）：在Linux当中，目录也是一种文件，该文件下存放的是这一目录下的<strong>inode</strong>号（又名<strong>索引节点</strong>）和文件名等信息。当执行打开文件时，Linux实际上是通过inode号找到当前文件所在block（8个磁盘扇区组成一个block），从而执行文件；
            <li>设备文件，又分为<strong>块设备文件</strong>（<code>b</code>）和<strong>字符设备文件</strong>（<code>c</code>）。其中前者可以以“块”为单位进行访问（例如硬盘，软盘等），而后者则是以“字节流”的方式访问（例如字符终端、键盘等）。一般来说，设备文件存放在<code>/dev/</code>目录下；
            <li>链接文件（<code>l</code>）：一般情况下指的是符号链接（软链接），类似于Windows操作系统下的“快捷方式”。创建符号链接的方法是使用<code>ln</code>的<code>-s</code>选项<sup>1</sup>，例如，<code>ln -s INCAR INCAR_link</code>表示创建了一个指向<code>INCAR</code>文件的链接文件<code>INCAR_link</code>。当源文件删除时，符号链接文件也会删除；
            <li>管道文件（<code>p</code>）：通常用于进程间的通信，创建方法是<code>mkfifo</code>命令<sup>2</sup>，即<code>mkfifo fifo_file</code>。
            <li>套接字文件（<code>s</code>）：用于通信（尤其是网络上的通信）。简单来说，这是为了避免多个进程或多个TCP连接同时在一个TCP协议端口传输数据造成混淆。一般来说，套接字文件包含目的IP地址，传输层使用协议（TCP或UDP）和使用的端口号，利用套接字文件将三个参数组合起来，从而在传输过程中实现并发服务。
        </ul>
    </div>

    <h3 id="subsec:查看文件-查看文件内容">查看文件内容 <code>cat</code>，<code>tac</code></h3>
    <div class="attention">
        <p>当然，从文件操作本身来说，第一件事应当是创建文件。但是，创建文件需要的内容较多（例如，需要一些<code>vi</code>编辑器的使用，可能还需要重定向命令，在后面的章节再详细介绍。</p>
        <p>如果是初学者，希望可以尽快上手的话，你可以试着在Windows本地用记事本创建一个文本文件，并在里面随意输入一些你喜欢的文字（建议使用英文，对于中文等非ASCII字符而言，可能会出现乱码。），然后利用远程终端将文件发送至服务器（对于MobaXterm而言，在终端左侧有一个目录列表，你可以直接将文件拖拽至相应的目录中；对于其他终端软件，请参考其软件具体的操作方法）。后面对文件的查看操作，都可以对这个文本文件进行。</p>
    </div>
    <p>首先需要了解的是，如何查看完整的文件。在Linux当中，查看文件内容的命令是<code>cat</code>，其基本用法是<code>cat &lt;文件路径名&gt;</code>例如，对于位于当前目录下的<code>INCAR</code>文件，可以使用<code>cat INCAR</code>查看其内容。</p>
    <p><code>cat</code>命令有一些常用选项，例如，可以使用<code>cat -n</code>或<code>cat -b</code>显示行号，二者的区别在于前者会显示所有行号，而后者只对有内容的行显示行号。如果文本中空行内容太多，可以使用<code>cat -s</code>对空行进行压缩，使其缩减为一个空行。</p>
    <p>相对地，命令<code>tac</code>也是查看所有内容，只不过它是从最后一行倒着输出。可以看出，<code>tac</code>本身就是命令<code>cat</code>倒着写。例如，<code>tac INCAR</code>表示从最后一行开始输出<code>INCAR</code>文件。</p>
    <div class="attention">
        <p>命令<code>cat</code>并不是单词“猫”的意思，而是连接concatenate的缩写。正如单词所表示的那样，<code>cat</code>最原始的功能，是连接多个文件。例如，有一个文件叫<code>a</code>，另一个文件叫<code>b</code>，执行命令<code>cat a b</code>，则会将两个文件内容按照顺序连接起来并输出。</p>
    </div>

    <h3 id="subsec:查看文件-关于文件后缀名">关于文件后缀名</h3>
    <p>对于熟悉Windows的用户而言，看到上面（包括之前的所有示例）也许都会有一个疑惑：在Linux当中，文件名为什么没有后缀？事实上，后缀名的重要性仅仅是Windows操作系统给你的一个“错觉”，让你误以为<strong>后缀名很重要</strong>。事实上，<strong>Windows操作系统的文件名后缀并不会影响这个文件本身</strong>。</p>
    <div class="attention">
        <p>虽然表示后缀名的<code>.</code>可以任意放置，但有一个地方比较特殊--文件名开头。对于以<code>.</code>开头的文件名而言，它表示的含义是隐藏文件（这在<a href="#subsec:目录操作-关于隐藏文件">关于隐藏文件</a>一节介绍过了）</p>
    </div>
    <p>对于Windows操作系统而言，使用后缀名往往是为了决定文件的打开方式（取决于Windows特有的<strong>注册表</strong>）；而Linux文件大多都是文本文件（甚至系统配置也是文本文件），因此在Linux当中，文件后缀名就变得不重要了。也正因如此，在Linux当中你可以类似于Windows后缀名的方式创建任何的后缀（<code>*.jpg</code>,<code>*.xyz</code>甚至<code>*.zjq</code>,<code>*.ykn</code>都是可以的），在Linux看来，它们仅仅是文件名的一部分。</p>
    <p>甚至，在Linux当中，大多时候文件都是没有后缀名的。这也就是之前的<code>INCAR</code>和<code>OUTCAR</code>为什么没有后缀。对于从Windows创建的文本文件上传至服务器而言，可能还留有所谓的后缀名<code>*.txt</code>，你完全可以使用<code>mv</code>命令将后缀名删去，丝毫不影响文件本身和其他命令的运行。</p>

    <h3 id="subsec:查看文件-按页查看文件">按页查看文件 <code>more</code>，<code>less</code></h3>
<p>使用<code>cat</code>和<code>tac</code>查看文件，都是“一股脑”输出到终端里，对于比较短的文件而言，这种方法是可行的；如果这个文件很长，则要上下翻页就会比较繁杂。</p>
<p>对于多页的文件而言，Linux可以使用<code>more</code>命令查看。基本用法是<code>more <文件路径名></code>。例如，使用<code>more ../band/OUTCAR</code>就可以查看上一级目录下的<code>band</code>目录下的<code>OUTCAR</code>文件。在查看过程中，可以<strong>使用空格进行翻页，使用回车进行下一行查看</strong>。</p>
<div class="attention">
<p>在查看过程中，可以随时使用<code>q</code>键退出。</p>
<p>对于一些需要往回翻页查看的文件，可以使用<code>less</code>命令。基本调用格式与<code>more</code>类似，即<code>less <文件路径名></code>。与<code>more</code>不同的是，<code>less</code>命令可以向上翻页（使用<code>Page Up</code>键或者<code>b</code>键）<sup>3</sup>。</p>
<p>除次之外，也可以使用<code>d</code>向后翻半页，使用<code>u</code>向前翻半页。</p>
<p>对于<code>more</code>而言，实际上也可以通过<code>b</code>键实现向前翻一页的效果。但相比于<code>less</code>而言，<code>more</code>的自由性并不是太高。而且，使用<code>b</code>向前翻页的效果对于管道文件无法实现。</p>
<p>此外，<code>less</code>还有更复杂的“搜索功能”，例如，可以使用符号<code>/<字符串></code>的方法实现向下搜索，使用符号<code>?<字符串></code>的方法实现向上搜索。同时，<code>less</code>的其他命令都是在显示文件后的操作，并不是类似于之前的“选项”（即使用<code>-</code>的形式），这种方法与vi的使用类似。</p>
</div>
<p>无论是<code>more</code>还是<code>less</code>，都可以使用<code>q</code>键退出显示文件。</p>

<h3 id="subsec:查看文件-取头部和取尾部">取头部<code>head</code>和取尾部<code>tail</code></h3>
<p>有时，可能会希望仅仅查看一个文件的开头或者结尾。此时可以使用Linux操作系统下的<code>head</code>和<code>tail</code>命令。这两个命令的基本调用方法都是一样的，即<code>head &lt;文件路径名&gt;</code>和<code>tail &lt;文件路径名&gt;</code>。例如，使用<code>head POSCAR</code>就可以查看当前目录下<code>POSCAR</code>文件开头几行，同理，使用<code>tail relax/OSZICAR</code>就可以查看<code>relax</code>目录下的<code>OSZICAR</code>文件结尾几行。</p>
<div class="attention">
    <p>通常情况下，直接调用<code>head</code>和<code>tail</code>得到的都是开头（或结尾）10行的内容。在有些时候，可能会希望输出更多行，或者少输出几行避免混乱。此时可以使用参数<code>-n</code>实现，其基本格式为<code>head -n &lt;行数&gt; &lt;文件路径名&gt;</code>和<code>tail -n &lt;行数&gt; &lt;文件路径名&gt;</code>，这一选项表示输出指定的行数。例如，<code>head -n 5 POSCAR</code>可以查看<code>POSCAR</code>文件开头5行。对于<code>tail</code>同理。</p>
    <p>除此之外，<code>head</code>和<code>tail</code>还提供了选项<code>-c</code>，表示输出开头（或结尾）多少个字符的内容，格式与上面<code>-n</code>选项类似，即<code>head -c &lt;字符数&gt; &lt;文件路径名&gt;</code>和<code>tail -c &lt;字符数&gt; &lt;文件路径名&gt;</code>。</p>
</div>

<h3 id="subsec:查看文件-错误处理">错误处理</h3>
<h4>cat: &lt;文件名&gt;: Is a directory</h4>
<p><code>cat</code>命令仅限于查看文件内容，若后面所接内容为一个目录，例如，<code>cat vasp/</code>则会报错</p>

<h4>输入<code>cat</code>命令后忘记输入文件名直接回车，输入文件名后结果只输出了文件名，并没有输出内容</h4>
<p>当直接调用<code>cat</code>而没有接任何参数时，表示将终端标准输入所读取到的内容输出到终端。对于普通调用<code>cat &lt;文件路径名&gt;</code>而言，是将读取到的文件输出到终端。若没有任何参数，则会读取后面输入的内容。</p>
<p>退出的方法则是使用<code>ctrl+d</code>键结束当前输入，或者使用<code>ctrl+c</code>键强制终止当前命令。</p>

<h4>cat: &lt;文件名&gt;: No such file or directory</h4>
<p>文件路径不存在，检查一下路径（尤其是当前工作路径）是否正确。</p>

<h4>head（或tail）: invalid number of lines: &lt;文件名&gt;</h4>
<p>当你使用<code>head -n</code>或<code>tail -n</code>时，后面的行数是必须提供的一个参数。若没有提供行数，则会报错。</p>

<h4>head（或tail）: cannot open &lt;文件名&gt; for reading: No such file or directory</h4>
<p>文件路径不存在，检查一下路径（尤其是当前工作路径）是否正确。</p>

<h4>head（或tail）: error reading &lt;文件名&gt;: Is a directoryy</h4>
<p>类似于使用<code>cat</code>打开目录，使用<code>head</code>或<code>tail</code>打开目录就会报这种错误。</p>

<h4>使用<code>more</code>查看文件，输出*** &lt;文件名&gt;: directory ***</h4>
<p>这是因为试着用<code>more</code>查看目录而不是文件。</p>

<h4>使用<code>less</code>查看文件，输出许多奇怪的路径，不是想要的内容</h4>
<p>如果你仔细看一下里面的内容就会发现，当你用<code>less</code>查看目录时，输出的是这个目录下所有的文件和目录（包括隐藏文件）。事实上，使用<code>less &lt;目录路径&gt;</code>得到的结果和使用<code>ls -l &lt;目录路径&gt;</code>是一样的。只不过前者是单独输出的，而后者是直接输出在终端里。</p>

<h4>Missing filename ("less --help" for help)</h4>
<p>在调用<code>less</code>时忘记提供文件路径了。</p>

<h4>more: bad usage Try 'more --help' for more information.</h4>
<p>与上面的错误类似，在调用<code>more</code>时忘记提供文件路径了。</p>

<footer>
    <ol>
        <li id="ftnt1">相对地还有“硬链接”，直接使用<code>ln</code>即可。对于硬链接而言，二者本质上是一个文件（类似于做了备份），当其中一个删除时，另一个不会删除；当其中一个文件修改时，另一个也会同时修改。</li>
        <li id="ftnt2">也许你会疑惑为什么是fifo而不是管道的单词pipe。事实上，FIFO是一种数据缓存器执行方法，即“先进先出”（First In First Out）。作为数据缓存器，其与普通存储器的区别是没有外部读写地址线，这样使用起来非常简单，但缺点就是只能顺序写入数据，顺序的读出数据。数据地址在内部由指针自动加1实现，而不能通过地址线寻找地址。而Linux进程间的通信大多就是采用这种通信方式，这种方式也是管道的特性。相对的，还有一种LIFO，即“后进先出”（Last In First Out），通常“堆栈”（Stack）就是采用这种方法。</li>
<li>除次之外，也可以使用<code>d</code>向后翻半页，使用<code>u</code>向前翻半页。</li>
</ol>
</footer>
        </div>
        <div id="linuxCompress" class="chapter-content" style="display: none;">
            <h2>1.5 压缩与解压缩</h2>
            <p><strong>作者：</strong>Jiaqi Z.</p>
    
    <h3>知识点</h3>
    <ul>
        <li>如何压缩文件</li>
        <li>如何解压缩文件</li>
    </ul>

    <h3 id="subsec:压缩与解压缩-备份和压缩">备份和压缩</h3>
    <div class="extend">
        <p>虽然在许多场合，会将Linux的一些使用<code>tar</code>的操作说成是压缩文件和解压缩文件，但这个表述实际上是不贴切的。事实上，<code>tar</code>的本意是tape archive，指的是“磁带存档”，是为将若干个文件归档到磁带上，从而方便备份而设计的。而压缩文件实际上在<code>tar</code>当中经历了另外的步骤，即gzip压缩，或者是bzip2压缩等。这些在命令上都是通过额外的选项实现的。</p>
        <p>但是，由于现在大多数时候都是习惯于将两个步骤合二为一，包括使用gzip压缩后得到的<code>.gz</code>文件也可以在Windows操作系统下解压缩，从而极大方便了文件之间的跨系统传输。因此，在通常情况下，我们使用到的都是“压缩”。这里之所以给出两者的不同仅作为补充扩展用，在后续表述中，往往不做区分，一律表述为“压缩”和“解压缩”。</p>
    </div>

    <h3 id="subsec:压缩与解压缩-使用tar命令压缩文件">使用tar命令压缩文件</h3>
    <p><code>tar</code>命令在使用时通常会配合许多选项，在官方文档中，选项就有50个左右甚至更多，因此，我们不可能在这里完全介绍完所有的选项。对于一般的科研工作而言，只需要掌握几个最基本的选项即可。</p>
    <p>首先一个最基本的选项是<code>tar -c</code>，表示<strong>创建备份文件</strong>。通常仅有这一个参数是不够的，还需要配合以如<code>tar -f</code>参数，这一参数表示<strong>指定备份文件</strong>。结合这两个选项，可以得到一个备份文件的基本模式为：<code>tar -cf &lt;备份文件路径&gt; &lt;要备份的文件1路径&gt; &lt;要备份的文件2路径&gt; ...</code>。例如，<code>tar -cf vasp.tar INCAR KPOINTS POSCAR POTCAR</code>表示将当前目录下的<code>INCAR</code>,<code>KPOINTS</code>,<code>POTCAR</code>和<code>POSCAR</code>备份至当前目录的<code>vasp.tar</code>当中。</p>
    <div class="attention">
        <p><code>-cf</code>后面的参数，除第一个是备份文件路径外，后面所有参数都是要备份的文件路径。</p>
    </div>
    <p>正如<a href="#subsec:压缩与解压缩-备份和压缩">备份和压缩</a>所说的关于压缩和备份的区别一样，我们这里所做的仅仅是备份。对于真正的压缩，我们还需要添加一个压缩格式<sup>1</sup>。对于常见的gzip压缩格式而言，使用的选项是<code>tar -z</code>。因此，一个完整的压缩命令可以表示为<code>tar -czf &lt;压缩文件路径&gt; &lt;要压缩的文件1路径&gt; &lt;要压缩的文件2路径&gt; ...</code>。</p>
    <div class="attention">
        <p>一般情况下，使用gzip压缩的文件后缀名都是<code>.gz</code>。</p>
    </div>
    <p>对于上面所提到的备份例子，你能想到它的压缩命令是什么吗？</p>
    <p><strong>答案：</strong><code>tar -czf vasp.tar.gz INCAR KPOINTS POSCAR POTCAR</code></p>

    <h3 id="subsec:压缩与解压缩-解压缩">解压缩</h3>
    <p>相对地，有了压缩过程，就一定会有<strong>解压缩</strong>过程。首先，先忽略掉压缩格式（即gzip等相关内容），仅仅从备份的角度，考虑它的逆过程，也就是<strong>还原文件</strong>。</p>
    <p>在<code>tar</code>当中，可以使用选项<code>tar -x</code>实现备份文件的还原。例如，在开始的备份操作中，可以使用<code>tar -xf vasp.tar</code>实现对备份文件<code>vasp.tar</code>的还原。对于解压缩过程，选项完全类似，只需要使用<code>tar -xzf</code>即可。例如，对上面的<code>vasp.tar.gz</code>进行解压缩，可以使用<code>tar -xzf vasp.tar.gz</code>。</p>

    <h3 id="subsec:压缩与解压缩-查看压缩文件">查看压缩文件</h3>
    <p>这里所说的查看压缩文件，主要指的是查看<strong>压缩包内的文件</strong>，从更广义的角度看，就是查看所谓的“备份”文件。</p>
    <p>首先，在<code>tar</code>里面有一个选项<code>tar -v</code>，可以在压缩（解压）过程中查看压缩（解压）的文件。例如，上面的压缩和解压命令，分别可以写成<code>tar -cvf vasp.tar INCAR KPOINTS POSCAR POTCAR</code>和<code>tar -xvf vasp.tar</code>。对于gzip格式的压缩和解压缩，只需要在参数里额外添加<code>-z</code>即可。</p>
    <div class="attention">
        <p>在使用<code>tar -t</code>时，往往需要配合以<code>-f</code>参数指定压缩文件名。其完整用法为<code>tar -tf &lt;压缩文件路径&gt;</code>。例如，使用<code>tar -tf vasp.tar</code>可以查看<code>vasp.tar</code>压缩文件中的文件列表。</p>
        <p>无论是普通的备份文件，还是使用gzip压缩的文件，都是使用<code>tar -tf</code>查看（没有选项<code>-z</code>）。</p>
        <p>使用<code>tar -tvf</code>同样可以得到文件列表，只是输出的内容更详细（类似于<code>ls -l</code>的输出结果）</p>
    </div>
    <p>除此之外，查看压缩文件还有一种方法，使用<code>less</code>命令。通过<code>less &lt;压缩文件路径&gt;</code>可以直接查看压缩文件内容，其形式上类似于<code>tar -tvf</code>和<code>ls -l</code>。</p>

    <h3 id="subsec:压缩与解压缩-压缩文件的追加与合并">压缩文件的追加与合并</h3>
    <p>虽然已经非常小心地创建了压缩文件，但有时还是会有遗漏。例如，当你将<code>INCAR</code>,<code>POSCAR</code>,<code>KPOINTS</code>和<code>POTCAR</code>已经添加到<code>vasp.tar</code>之后，突然发现还应当把<code>CONTCAR</code>添加进去。如果此时文件还保留着，当然，重新使用<code>tar -cf vasp.tar ...</code>也是可以的（其中...表示五个文件路径）。但是，如果之前的文件已经删除了呢？解压后再重新压缩也不是不可行，但总是麻烦一步。</p>
    <p>在<code>tar</code>的选项中，提供了一个选项<code>tar -r</code>表示<strong>将文件追加到压缩文件内</strong>。例如，上面的例子，可以直接使用<code>tar -rf vasp.tar CONTCAR</code>即可将<code>CONTCAR</code>添加到<code>vasp.tar</code>中（哪怕原先的四个原始文件删除了也没关系）。</p>
<p>上面的例子是将文件追加到压缩文件内，如果是<strong>将压缩文件内的所有文件全部追加到另一个压缩文件里呢</strong>？可以使用<code>tar -A</code>选项。其格式为<code>tar -Af <追加的目标压缩文件路径> <追加的压缩文件路径></code>。例如，我们已经有了包含<code>INCAR</code>,<code>KPOINTS</code>,<code>POSCAR</code>,<code>POTCAR</code>的压缩文件<code>vasp.tar</code>，此时又有一个压缩文件<code>result.tar</code>，里面包含有<code>OUTCAR</code>,<code>CONTCAR</code>，如何将其合并到共同的<code>vasp.tar</code>当中呢？可以使用<code>tar -Af vasp.tar result.tar</code>。</p>
<div class="attention">
<p>这里的选项<code>-A</code>是大写字母，千万不要写成小写字母。二者的含义不同，对于小写字母<code>tar -a</code>，表示根据后缀来决定压缩格式。例如，使用<code>tar -caf vasp.tar.gz INCAR</code>将会以gzip格式创建压缩文件。</p>
<p>同时，使用<code>-A</code>合并压缩文件时，只能对两个文件进行合并。</p>
</div>

<h3 id="subsec:压缩与解压缩-错误处理">错误处理</h3>
<h4>tar: &lt;压缩文件路径&gt;: Cannot stat: No such file or directory \\tar: Exiting with failure status due to previous errors</h4>
<p>通常这是因为在调用<code>tar</code>时错误放置了压缩文件路径和被压缩的文件路径的位置。在使用<code>tar</code>进行压缩时，第一个参数是压缩文件路径，第二个参数是被压缩的文件路径。</p>
<p>例如，对前面的例子，如果使用的是<code>tar -czvf INCAR KPOINTS POSCAR POTCAR vasp.tar.gz</code>，就会报错。</p>

<h4>tar: Refusing to write archive contents to terminal (missing -f option?) \\tar: Error is not recoverable: exiting now</h4>
<p>在使用<code>tar</code>进行压缩（或解压）时，需要给定选项<code>-f</code>并指定压缩文件名，例如<code>tar -cf vasp.tar INCAR</code>。如果没有选项<code>-f</code>则会报错。</p>

<h4>tar: Cowardly refusing to create an empty archive</h4>
<p>这意味着你在压缩文件时试图压缩空的文件。这通常是因为你没有指定压缩文件（例如，直接调用<code>tar -cf vasp.tar</code>就会报错）。</p>
<p>还有一种可能是你错用了压缩选项<code>-c</code>和解压缩选项<code>-x</code>。例如，也许上面的命令你是想解压<code>vasp.tar</code>，那么你需要的命令是<code>tar -xf vasp.tar</code>。</p>

<h4>tar: &lt;压缩文件路径&gt;: file is the archive; not dumped</h4>
<p>这可能是因为你在压缩文件时<strong>对压缩文件本身进行压缩</strong>，这可能会造成<strong>递归</strong>压缩。例如，<code>tar -cf vasp.tar vasp.tar</code>时就会报错。</p>
<p>但是，<strong>压缩文件本身是可以被压缩的</strong>。例如，<code>tar -cf vasp.tar result.tar</code>是允许的，这执行的操作是将<code>result.tar</code>文件压缩至压缩包<code>vasp.tar</code>当中。</p>

<footer>
    <ol>
        <li id="ftnt1">所谓的<strong>压缩格式</strong>，在Windows系统下常见的如zip、rar等，而在Linux操作系统下，最常见的是gzip，当然也有如bzip、xz等。</li>
    </ol>
</footer>
        </div>
        <div id="linuxFilePermission" class="chapter-content" style="display: none;">
            <h2>1.6 文件权限管理</h2>
            <p><strong>作者：</strong>Jiaqi Z.</p>
    
    <h3>知识点</h3>
    <ul>
        <li>用户、用户组和其他用户</li>
        <li>如何查看文件权限</li>
        <li>如何修改文件权限</li>
    </ul>

    <h3 id="subsec:文件权限管理-用户和用户组">用户和用户组</h3>
    <p>Linux是一个多用户操作系统，因此，如何管理不同用户就成为一个至关重要的话题。例如，在科研过程中，同一课题组的多个成员可能会使用同一个服务器，此时每一个成员就是Linux当中的<strong>用户</strong>。每一个用户通常都有一个主目录，通常为<code>/home/</code>下的目录<sup>1</sup>。</p>
    <p>在<a href="#subsec:目录操作-显示目录文件">显示目录文件</a>当中介绍过如何使用<code>ls -l</code>查看一个文件的完整信息，其中提到了<strong>用户组</strong>的概念。顾名思义，用户组就是<strong>用户的组合</strong>。举一个例子：如果我们把你家庭的房子看作一个Linux操作系统的话，那么你的家人和你就组成一个用户组。而每一个人就是一个用户。对于家庭的共有物品而言（例如空调、冰箱等）是所有家人可以共同使用的，即对整个用户组可用；而相对地，你的房间，你的柜子可能只是你自己可以打开，此时我们说只对某一特定用户可用。</p>
    <p>相对地，对于不是你家庭成员的其他人（比如你的邻居等），他们是属于其他用户组的用户，对于你家的所有东西都不可用。</p>
    <div class="attention">
        <p>上面的例子也许你还看得“一头雾水”，什么可用、不可用，到底有什么用。事实上，用户组的应用场景大多集中在关于权限的操作上。而这件事则是下一部分的内容。</p>
        <p>同时，前面提到的所有用户中有一个特殊用户--<strong>root</strong>用户。对于他而言，拥有最高的权限和能力，即可以进入任何地方。也正如在前面多次提到的那样，对于一般科研工作而言，不需要了解root的相关内容。因此在这里，我们就将其略过去了。</p>
    </div>

    <h3 id="subsec:文件权限管理-文件权限">文件权限</h3>
    <p>前面介绍<code>ls -l</code>命令时已经说明了一些关于文件权限的内容，现在来进一步介绍<strong>如何查看文件权限</strong>，以及<strong>如何理解文件权限的含义</strong>。</p>
    <p>与前面所介绍的一样，文件权限可以利用<code>ls -l</code>或者<code>ll</code>查看。通常来说，每一个文件（包括目录）的第一组字符串表示了文件类型和参考文献。其中文件类型的相关内容已经在<a href="#subsec:查看文件-Linux文件类型">Linux文件类型</a>当中介绍过了，现在我们重点关注后面九个字符，即<strong>文件权限</strong>。</p>
    <p>以<code>/bin</code>目录下的<code>cd</code>文件为例<sup>2</sup>，使用命令<code>ls -l /bin/cd</code>可以得到如下结果</p>
    <pre><code class="bash">$ ls -l cd
-rwxr-xr-x. 1 root root 26 Oct  9  2021 cd
</code></pre>
    <p>输出结果的第一个部分就是文件权限。其中第一个字符<code>-</code>表示这个文件是一个<strong>普通文件</strong>，后面的9个字符，每三个一组，分别表示<strong>拥有者</strong>，<strong>所属用户组</strong>和<strong>其他用户</strong>的权限。例如，对于<code>cd</code>文件为例，拥有者（即输出结果的第三部分<code>root</code>）的权限是<code>rwx</code>；而所属用户组（输出结果的第四部分<code>root</code>）具有<code>r</code>和<code>x</code>的权限；同样，对于其他用户来说，也是具有<code>r</code>和<code>x</code>权限。</p>
    <div class="extend">
        <p>在这里你见到了<code>ls -l</code>的新用法，即在后面添加一个文件的路径。即<code>ls -l &lt;文件路径&gt;</code>，可以查看该文件的属性。</p>
        <p>同时，也许你注意到上面的第一部分输出结果还有一个<code>.</code>，这表明该文件是在SELinux模式下创建的。其中SELinux叫做安全增强型Linux（Security-Enhanced Linux），其目的在于最大限度地减小系统中服务进程可访问的资源<sup>3</sup>。对于使用SELinux模式创建的文件，在权限后面会有<code>.</code>作为标志（如同上面的<code>cd</code>命令一样）。</p>
    </div>
    <p>在文件权限中，每种用户又包含有<strong>可读权限</strong>（<code>r</code>），<strong>可写权限</strong>（<code>w</code>）和<strong>可执行权限</strong>（<code>x</code>）。可读权限表明用户可以读取文件内容，对于目录而言表示用户可以查看目录内文件；可写权限表明用户可以修改文件内容，对于目录表示用户可以移动、删除目录内文件；可执行文件表明用户可以执行文件（一般为脚本文件或其他程序），对于目录表明用户可以进入目录。</p>
    <div class="attention">
        <p>每种用户的权限一共就这三种，且数量和顺序都是固定的（即<code>rwx</code>）；对于没有的权限，使用短横线<code>-</code>表示无该权限。例如，<code>r-x</code>表示可读可执行，但不可写（如同上面的<code>/bin/cd</code>一样）。</p>
    </div>
    <p>考虑一个很简单的例子：如果一个文件的权限表示为<code>-rw-rw-r--</code>，对其他用户而言，含义是什么呢？</p>
    <p><strong>答案：</strong>该文件对其他用户而言只读。</p>

    <h3 id="subsec:文件权限管理-修改文件权限">修改文件权限 <code>chmod</code></h3>
    <p>在Linux当中，可以使用<code>chmod</code>修改文件的权限。修改方式有2种，第一种是直接设定三种用户的所有权限（共9位）。但是，如果直接写类似于<code>rw-rw-r--</code>这样子的形式的话，就稍显繁琐。如果考虑到特定的位数，可以把这三个权限的开关看作二进制的“0”和“1”，其中拥有权限为“1”。这样子就可以通过1个十进制数字表示一种用户的权限。例如，对于<code>r--</code>，可以将其写作<code>100</code>也就是十进制的<code>4</code>；类似地，对于<code>r-x</code>，可以写作<code>101</code>也就是<code>5</code>。</p>
    <div class="extend">
        <p>关于进制转换，对于任意一个$p$进制数<math xmlns="http://www.w3.org/1998/Math/MathML"><mo>⋯</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>0</mn></msub><mo>.</mo><msub><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msub><mo>⋯</mo></math>，其中<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>a</mi><mi>n</mi></msub><mo>,</mo><mi>n</mi><mo>∈</mo><mrow><mi mathvariant="double-struck">Z</mi></mrow></math>表示在<math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn><mo>∼</mo><mi>p</mi><mo>−</mo><mn>1</mn></math>范围内的数，将其转化为十进制的方法是</p>
        <p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><munder><mo data-mjx-texclass="OP">∑</mo><mi>i</mi></munder><msub><mi>a</mi><mi>i</mi></msub><msup><mi>p</mi><mi>i</mi></msup></math></p>
        <p>例如，对于二进制数101，转化为十进制可以算作<math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo>×</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mn>0</mn><mo>×</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mn>0</mn></msup><mo>=</mo><mn>5</mn></math>。对于十进制转二进制，可以使用<strong>短除法</strong>进行，具体可以参考网站<a href="https://blog.csdn.net/Mud_Bodhisattva/article/details/106837915">短除法</a>。</p>
        <p>在有些专业教材中，可能会使用<code>0b</code>表示二进制数，例如<code>0b101</code>，其中<code>b</code>为二进制单词binary的缩写。</p>
    </div>
    <p>使用这种数字表示方法修改权限的格式为<code>chmod &lt;权限&gt; &lt;文件路径&gt;</code>。例如，对<code>supercell</code>文件执行<code>chmod 755 supercell</code>则表示最终的权限为<code>rwxr-xr-x</code>。</p>
    <p>思考一下，如果想让一个目录只对所有者提供全部权限，而其他人无权限，用数字表示应当怎么写？</p>
    <p><strong>答案：</strong>700表示<code>rwx------</code></p>
    <p>虽然这种方法可以修改所有权限，但有时我们仅仅希望添加或删除某一特定的权限。例如，当我们编写了一个程序后，可能只希望给它添加一个对所有者的可执行权限，甚至不关心它对其他用户的权限如何，如果再一点点算，就有点麻烦。例如，原本的权限是<code>rw-r--r--</code>，诚然使用<code>chmod 744 &lt;文件路径名&gt;</code>可以实现这一功能，但有没有更简单的方法呢？</p>
    <p>在<code>chmod</code>命令中，除了使用数字表示权限外，还可以利用如<code>+</code>, <code>-</code>和<code>=</code>这样的符号进行增添、删除或修改权限。其基本用法为<code>chmod [用户]&lt;操作符&gt;&lt;权限&gt; &lt;文件路径&gt;</code>。其中<code>[用户]</code>表示想给所有者（<code>u</code>），所属用户组（<code>g</code>）还是其他用户（<code>o</code>）修改权限。对于操作符而言，<code>+</code>, <code>-</code>和<code>=</code>分别表示增加权限、删除权限和更改权限。后面的<code>&lt;权限&gt;</code>使用<code>r</code>, <code>w</code>, <code>x</code>这种表示方法。</p>
    <p>举个例子，如果我们希望给文件所有者添加一个可执行权限，则可以直接执行<code>chmod u+x &lt;文件路径&gt;</code>即可；如果希望给其他人删除可读权限，则使用<code>chmod o-r &lt;文件路径&gt;</code>。如果希望给所有者和所属组设置为可读写权限的话，可以用<code>chmod ug=rw &lt;文件路径&gt;</code>。</p>
    <div class="attention">
        <p>正如后面的例子所展示的那样，<code>[用户]</code>和<code>&lt;权限&gt;</code>都可以一次性写多个。当然，有时可能会希望一次性给所有用户设置权限，例如给所有人可读写权限，在<code>chmod</code>当中，对于<code>[用户]</code>还提供了一个选项<code>a</code>，表示<strong>所有人</strong>。例如，<code>chmod a=rw &lt;文件路径&gt;</code>表示设置为所有人可读写。</p>
        <p>同时，利用这种方法也可以设置不同的权限，即一次性设置多个用户，其中用<code>,</code>分隔。例如，如果希望将权限设置为<code>rwxrw-r--</code>，则可以直接写作<code>chmod u=rwx,g=rw-,o=r-- &lt;文件路径&gt;</code></p>
    </div>

    <h3 id="subsec:文件权限管理-错误处理">错误处理</h3>
    <h4>希望给文件所有者自己设置权限，使用数字之后为什么给其他用户设置权限了，而所有者没有权限</h4>
    <p>在使用数字表示的时候，三位分别表示所有者、所属组和其他用户。对于不足三位的数字，其前面默认<strong>补零</strong>，例如，<code>chmod 7 &lt;文件路径&gt;</code>实际上等价于<code>chmod 007 &lt;文件路径&gt;</code></p>
    <div class="extend">
        <p>对于稍微了解计算机的读者来说，也许你已经有所察觉了。我们之前说这个数字是十进制数字，但严格来说，它是<strong>八进制</strong>数字。对于八进制而言，它的每一个数位上的数字，都与3位二进制对应。例如，八进制的7表示二进制的111，八进制的3表示二进制的011等。具体转换如表<a href="#tab:文件权限管理-十进制，二进制和八进制对应表">十进制，二进制和八进制对应表</a>所示。</p>
        <table id="tab:文件权限管理-十进制，二进制和八进制对应表">
            <tr>
                <th>十进制</th>
                <th>二进制</th>
                <th>八进制</th>
                <th>十进制</th>
                <th>二进制</th>
                <th>八进制</th>
            </tr>
            <tr>
                <td>0</td>
                <td>000</td>
                <td>0</td>
                <td>4</td>
                <td>100</td>
                <td>4</td>
            </tr>
            <tr>
                <td>1</td>
                <td>001</td>
                <td>1</td>
                <td>5</td>
                <td>101</td>
                <td>5</td>
            </tr>
            <tr>
                <td>2</td>
                <td>010</td>
                <td>2</td>
                <td>6</td>
                <td>110</td>
                <td>6</td>
            </tr>
            <tr>
                <td>3</td>
                <td>011</td>
                <td>3</td>
                <td>7</td>
                <td>111</td>
                <td>7</td>
            </tr>
        </table>
        <p>在一些专业的计算机书籍或其他地方，八进制会用<code>0o</code>作为前缀（其中第一个是数字0，第二个是小写字母o）。例如，0o5=0b101=5。当然，因为八进制每一个数位的范围0到7小于十进制0到10的区间，因此对于7以内的数字而言，八进制和十进制是一样的。但随着数字增加，二者会出现差别，但八进制和二进制之间仍存在一一对应关系。例如，23=0b010111=0o27。</p>
        <p>事实上，每三位二进制的对应关系产生了八进制，而目前更常用的是四位二进制对应关系所产生的十六进制（前缀为<code>0x</code>）。</p>
    </div>
        </div>
        <div id="linuxNano" class="chapter-content" style="display: none;">
            <h2>2.1 使用nano简单创建文件</h2>
            <p><strong>作者：</strong> Jiaqi Z.<p>

                <h3>知识点</h3>
                <ul>
                <li>如何使用<code>nano</code>创建并编辑文本文件</li>
                </ul>
                
                <p>
                在Linux命令行操作一章当中，已经了解了如何对Linux进行基本的操作，例如查看目录、移动或删除文件等，同时在文件权限管理一节讨论了如何给文件添加权限，例如，给脚本程序添加可执行权限。
                </p>
                
                <p>
                然而，我们在Linux的所有对文件的操作，目前只限于<strong>读取</strong>，对于编辑，目前所采用的方法是将其保存至Windows下，利用记事本等软件进行编辑，完成后再上传回Linux系统。然而，无论是使用Linux本地操作系统，还是在服务器上使用，如果可以在系统中直接编辑文件，显然更方便<sup>1</sup>。在本章，我们将详细介绍Linux下如何编辑文件。
                </p>
                
                <p>
                目前，Linux最常用的文本编辑器是vi和vim，而在这之前，我们先介绍一个更简单的文本编辑器--<code>nano</code>。相比于vi和vim，<code>nano</code>功能可能会更少，但是作为开始Linux文件编辑的第一步，也许是合适的。
                </p>
                
                <div class="extend">
                <p>
                    在很多时候，我们会把vi和vim放在一起讨论。它们具有类似的界面，类似的工作模式，因此很多人容易将其混为一谈。实际上，vi是由Bill Joy在1976开发的一款Unix操作系统下的可视化编辑器（Linux是1991年诞生的）；而vim是Bram Moolenaar在1991年开发的vi改进版（Vi improved），其功能包含语法高亮、插件支持等。
                </p>
                <p>
                    虽然我们经常在Linux当中使用vim，但它本身是可以跨平台运行的，如Windows本身也是可以安装支持vim。只不过由于Windows本身的文本编辑软件足够丰富，同时大多数Windows用户并不熟悉命令行操作本身。因此，很多人也是在接触Linux的时候第一次接触vim编辑器。
                </p>
                <p>
                关于二者之间的更多区别，可以查看网址：<a href="https://blog.csdn.net/weixin_53269650/article/details/138137434">Linux中的vi与vim：编辑器的王者之争与深度探索</a>
                </p>
                </div>
                <h3 id="subsec:使用nano简单创建文件-使用nano创建第一个文件">使用<code>nano</code>创建第一个文件</h3> 
                <p>
                使用<code>nano</code>命令非常简单，通常只需要使用<code>nano &lt;要打开的文件路径名&lt;</code>，对于不存在的文件，它会自动创建一个；而已经存在的文件则会将其打开。
                </p>  
                <p>
                例如，在家目录下，我们直接创建一个名为<code>hello</code>的文件。使用命令<code>nano hello</code>，则会进入nano编辑器的模式。如果你用过老式操作系统，则会发现这个界面十分“复古”--上面是编辑区，下面是一些选项（类似于Windows软件的“菜单”）如图所示。
                </p>
                <img src="fig/nano界面.png" alt="nano界面" width="100%">
                <p>
                当打开时，软件默认就是<strong>编辑模式</strong>，你可以在里面随意输入一些内容，例如，输入“hello world”，屏幕上就是直接显示你的内容。对于删除和换行，其操作就如图在Windows下的记事本一样（使用键盘上下左右、删除键等）。重点是下面的菜单选项。难度本身也不大，只需要记住两个符号所表示的含义即可：^表示键盘上的<code>Ctrl</code>键，而<code>M-</code>表示键盘上的<code>Alt</code>键。因此，正如你所看到的那样，在nano当中，使用<code>Ctrl+X</code>退出；使用<code>Ctrl+O</code>保存。
                </p>
                <div class="attention">
                <p>
                    在<code>nano</code>当中，一个很特殊的地方在于它的复制、剪切和粘贴与我们所熟悉的快捷键不一样。根据下面的说明，可以看到，复制是<code>Alt+6</code>，剪切是<code>Ctrl+K</code>，而粘贴是<code>Ctrl+U</code>。
                </p>
                
                <p>
                    同时，无论是复制还是剪切，默认都是<strong>对行进行操作</strong>。也可以使用<code>Alt+A</code><sup>2</sup>，并用方向键选中文本，进行操作。
                </p>
                </div>
                <p>
                此外，<code>nano</code>也支持撤销（<code>Alt+U</code>）和恢复（<code>Alt+E</code>）。
                </p>
                
                <h3>使用<code>nano</code>进行查找和替换</h3>

                <p>几乎所有的文本编辑器，都需要有一些如<strong>查找</strong>查找和<strong>替换</strong>的功能方便我们进行编辑。在<code>nano</code>当中，查找的命令是<code>Ctrl+W</code>，此时下方会弹出一个输入框，输入要查找的内容，回车后光标便会定位在光标下方第一个匹配的开头位置。使用<code>Alt+↓</code>和<code>Alt+↑</code>可以切换到下一个匹配位置或上一个匹配位置。</p>

                <div class="attention">
                    <code>nano</code>在匹配查找时不区分大小写，例如，想查找<code>SIGMA</code>时，在输入查找内容时输入<code>sigma</code>同样可以。
                </div>

                <p> 对于替换功能，其命令为<code>Ctrl+\</code>，此时首先弹出对话框，输入要查找的内容的，之后弹出的对话框输入要替换的内容。之后光标会从当前位置开始向后搜索，当查找到一个后会定位到此处并询问是否替换。输入<code>y</code>表示确认，输入<code>n</code>表示不替换此处。如果确认要全部替换的话，可以直接输入<code>a</code>；相对地，如果发现有错（例如要查找的词语或要替换的词语拼写错了），可以输入<code>c</code>取消替换命令。
                </p>

                <p>除此之外，还有更多的命令（例如查看字数是<code>Alt+D</code>），可以直接使用<code>Ctrl+G</code>查看帮助文档。在帮助文档中还包含有一些命令的快捷方式，例如查看文档除了可以使用<code>Ctrl+G</code>外，也可以直接使用<code>F1</code>键。</p>

                <div class="attention">
                    <code>nano</code>的使用方法看似讲了很多，实际上只需要记住：^表示键盘上的<code>Ctrl</code>键，而<code>M-</code>表示键盘上的<code>Alt</code>键，其他的，都可以通过下方的说明，或者帮助文档找到。
                </div>

                <h3 id="subsec:使用nano简单创建文件-错误处理">错误处理</h3>

                <h4>[ File <文件名> is unwritable ]</h4>

                <p>这是因为你没有这个文件的可编辑权限。借助于<a href="#subsec:文件权限管理-修改文件权限">修改文件权限</a>一节所介绍的<code>chmod</code>命令可以添加可编辑权限。</p>

                <div class="attention">
                    大多数时候，之所以这个文件不可编辑，是因为这个文件含有重要内容（可能是你误打了一个系统文件的路径，虽说这个可能性很小）。因此，遵守这个权限，不要修改是最好的。如果确实需要修改，仔细检查。
                </div>

                <h4>[ Error reading <文件名>: Permission denied ]</h4>

                <p>这是因为你没有这个文件的可读权限，解决方法与上一个错误一样（使用<code>chmod</code>命令）</p>
                <p>与前面的注意内容一样，遵守这个权限往往是最正确的选择。</p>

                <footer>
                    <p>注解：</p>
                    <ol>
                    <li id="ftnt1">虽然在VS Code当中，也许可以如同本地文件一般编辑服务器上的文件，但作为Linux教程，我们还是会尽可能介绍普遍适用的方法。</li>
                    <li id="ftnt2">这个命令可能和部分软件（如微信）的截图快捷键冲突。</li>
                    </ol>
                </footer>
        </div>
        <div id="linuxViVim" class="chapter-content" style="display: none;">
            <h2>2.2 使用vi,vim创建文件</h2>
            <p><strong>作者：</strong> Jiaqi Z.<p>
            <h3>知识点</h3>
            <ul>
            <li>如何通过<code>vi</code>,<code>vim</code>创建并保存文件</li>
            <li>如何通过<code>vi</code>,<code>vim</code>打开已有文件</li>
            </ul>
            
            <h3 id="subsec:使用vi,vim创建文件-通过vi创建文件">通过<code>vi</code>创建文件</h3>

            <p>从本节开始，这一章就要开始讨论<code>vi</code>和<code>vim</code>的操作方法。类似于使用<code>nano</code>编辑文件，在Linux当中通过<code>vi</code>(<code>vim</code>)创建文件的方法是<code>vi &lt;文件名&gt;</code>或<code>vim &lt;文件名&gt;</code>。通常来说，使用<code>vi</code>创建文件后的界面如图所示。</p>

            <img src="fig/vim界面.png" alt="vim界面" width="100%">

            <div class="attention">
                <p>正如<a href="#linuxNano">使用nano简单创建文件</a>开头所说的那样，相比于vi，vim的功能更加强大。目前在很多操作系统当中，都是使用<code>vim</code>代替<code>vi</code>。因此，在本节标题中，我们使用<code>vi</code>和<code>vim</code>作为区分，在后面的讨论中，可能为了方便，我们使用<code>vi</code>代替<code>vim</code>（二者操作方法基本一致）。</p>

                <p>如果你确实想知道使用<code>vi</code>命令打开的是vim编辑器还是vi编辑器，可以使用<code>alias</code>命令，在输出中如果看到有<code>alias vi='vim'</code>，那么说明实际上你所打开的是vim编辑器；如果没有，则意味着打开的是vi。此时如果希望打开vim编辑器，则需要使用命令<code>vim</code>代替<code>vi</code>。</p>
            </div>

            <h3 id="vi编辑器的三种模式">vi编辑器的三种模式</h3>

            <p>与nano界面相比，vi界面显得更加“简洁”（没有了下方的菜单栏）。但是，如果你尝试着往里面输入内容的话，会发现往往不会是你想要的结果（也有可能“误打误撞”可以输入进去）。这是因为，在vi当中存在三种工作模式：</p>

            <h4>普通模式</h4>

            <p>当你使用<code>vi</code>命令打开编辑器后，则进入了编辑器的<strong>普通模式</strong>。在这一模式下，你可以使用方向键移动光标，也可以进行删除、剪切、粘贴等简单操作。</p>

            <p>一些简单的操作是使用<code>x</code>键删除当前光标所在字符，使用<code>dd</code>删除当前行（实际上是“剪切”），<code>yy</code>复制当前行；使用<code>p</code>（小写）将剪贴板内容粘贴到光标下方，<code>P</code>大写表示粘贴到光标上方。<code>u</code>表示撤销，<code>Ctrl+r</code>表示恢复撤销。</p>

            <p>上面这些操作都是比较基础简单的，通常是用于对文件进行<strong>修改</strong>的。而对于新创建的文件，则可以使用<code>i</code>进入到“编辑模式”。同时，使用<code>a</code>可以在光标下一个位置开始“编辑模式”，<code>o</code>（小写字母）和<code>O</code>（大写字母）分别表示在当前行下方和上方插入新的一行，并进入“编辑模式”</p>

            <h4>编辑模式</h4>

            <p>这是最熟悉的模式。可以在这一模式下如同正常文本编辑器一般进行编辑（例如，方向键移动光标，编辑字符，删除键等都是可用的）。除此之外，还有一些快捷键需要介绍一下<sup>1</sup>这些快捷键很多在Windows当中也有，但可能大多数人并不熟悉。</p>

            <p>使用键盘上的<code>Home</code>键和<code>End</code>键可以将光标定位到行首和行尾；使用<code>Page Up</code>和<code>Page Down</code>可以上下翻页；使用<code>Insert</code>可以在“插入模式”和“替换模式”下切换。</p>

            <p>在“编辑模式”下使用键盘上的<code>Esc</code>键可以返回到“普通模式”。</p>

            <h4> 命令行模式</h4>

            <p>这一模式将会是最复杂的，许多vi的高级操作都是基于一系列的命令完成的。进入命令行模式的方法是<strong>在“普通模式”下输入键盘上的<code>:</code></strong>。</p>

            <p>虽然大多数命令要在后面的章节提到它们，但一些必要的命令还是需要现在知道的--它们涉及到<strong>文件的保存</strong>和<strong>编辑器的关闭</strong>。例如，<code>:w</code>表示保存文件，<code>:q</code>表示关闭编辑器，<code>:q!</code>表示强制退出（不保存），而<code>:wq</code>表示保存后退出<sup>2</sup>。</p>

            <h3 id="subsec:使用vi,vim创建文件-通过vi打开已有文件">通过<code>vi</code>打开已有文件</h3>

            <p>类似于使用<code>nano &lt;文件路径&gt;</code>的方法，使用<code>vi</code>打开已有文件的方法是<code>vi &lt;文件路径&gt;</code>。与前面所介绍的内容一样，打开后的vi界面默认是“普通模式”，此时可以使用一些简单的方式（如<code>dd</code>删除整行等）对文件进行简单的编辑，或者可以使用“编辑模式”进行修改操作。</p>

            <div class="attention">
                <p>在修改文件时，请确保是否有修改文件的权限。对于没有权限的文件进行修改，在退出时将会返回“'readonly' option is set (add ! to override)”的错误。</p>

                <p>正如错误中所说的那样，你可以使用<code>w!</code>的方式强行覆盖文件，但这始终是一种“下策”。</p>
            </div>

            <h3 id="使用vi,vim创建文件-错误处理">错误处理</h3>

            <h4>E37: No write since last change (add ! to override)</h4>

            <p>这表明你在<code>:q</code>退出时文件发生了修改。类似于WIndows操作系统下退出时询问是否保存一样，你需要选择是否保存你的编辑。如果保存，则需要先执行<code>:w</code>再<code>:q</code>，或者直接执行<code>:wq</code>；相对地，如果你不需要保存，则执行<code>:q!</code>强制退出。</p>

            <h4>W10: Warning: Changing a readonly file</h4>

            <p>这是一个警告信息，说明你正在编辑一个对你而言有权限限制的文件（大多数时候是“只读”文件，但对于某些“不可读”文件，如果强行编辑，可能也会引起该错误）。如果无视编辑并保存的话，通常会引发下面的错误：</p>

            <h4>E45: 'readonly' option is set (add ! to override) </h4>

            <p>这是正文最后所提到的错误，说明你编辑了一个有权限限制的文件。使用<code>:w!</code>可以强行覆盖保存文件，但这并不是一个正确的方法（至少是不推荐的方法）。</p>

            <h4> [Permission Denied]</h4>

            <p>这是因为你在查看一个不可读的文件。当你尝试编辑时，则会引发上面的警告或错误。</p>

            <footer>
                <p>注解：</p>
                <ol>
                <li id="ftnt1">这些快捷键很多在Windows当中也有，但可能大多数人并不熟悉。</li>
                <li id="ftnt2">它还有一个形式：<code>:x</code>。</li>
                </ol>
                </footer>
        </div>
        <div id="linuxFindReplace" class="chapter-content" style="display: none;">
            <h2>2.3 查找与替换</h2>
            <p><strong>作者：</strong> Jiaqi Z.<p>

                <h3>知识点</h3>
                <ul>
                <li>使用<code>vi</code>的<code>/</code>和<code>?</code>进行字符串查找</li>
                <li>使用<code>vi</code>进行字符串的替换</li>
                </ul>

                <p>对于一个现代文本编辑器，一个最基本的功能就是对某一特定的字符串进行查找，以及将其替换为另一字符串。相比于其他在Windows操作系统中常见的文本编辑器（无论是记事本、word、还是VS Code等），Linux的vi编辑器下的查找和替换都显得更加复杂。这确实可能带来了一些学习上的困难，但随着使用场景逐渐复杂，你会发现这种代码式的操作的便利性。</p>

                <h3 id="subsec:查找与替换-查找">查找</h3>

                <p>
                    首先先来了解如何对一个字符串进行查找。在vi当中，查找的方法是使用<code>/</code>或者<code>?</code>，其基本格式为<code>/[要查找的字符串]</code>或者<code>?[要查找的字符串]</code>。例如，在当前文件中查找<code>Hello</code>，可以输入<code>/Hello</code>，然后回车。</p>

                <div class="attention">
                    <p> 在输入字符串时，vi会同时在文本内将所有匹配的字符串进行高亮（即便没有按回车）。</p>
                    <p><code>/</code>和<code>?</code>的作用都是查找字符串，二者的区别在于，<code>/</code>是从当前光标开始向后查找，而<code>?</code>是向前查找。当输入完成后，点击回车，光标会自动定位到最近的相应位置。若要切换，则可以使用<code>n</code>查找下一个或者使用<code>N</code>查找上一个。</p>
                </div>

                <h3 id="subsec:查找与替换-替换">替换</h3>

                <p>相比于查找命令，vi中的替换命令就显得更加复杂了。最基本的命令是<code>s</code>，但通常会配以更多的命令（类似于参数）。一般来说，替换命令可以用下面的方式表示：<code>:&lt;开始行号&gt;,&lt;结束行号&gt;s[分隔符][要替换的字符串][分隔符][替换为的字符串][分隔符]&lt;g&gt;</code>。其中<code>&lt;开始行号&gt;</code>和<code>&lt;结束行号&gt;</code>都是可选的，若省略则表示<strong>只对当前行进行替换</strong>。命令结尾的<code>&lt;g&gt;</code>也是可选的，表示对所有进行替换，若省略则只替换第一个（每一行或当前行，取决于是否有行号）。</p>

                <p>同时，在替换时需要使用<code>[分隔符]</code>对字符串进行分割，通常情况下习惯于使用<code>/</code>表示，但在一些特殊的情况下（例如要替换的字符串内带有这一字符），则可能会将其改为其他分隔符。命令当中所有出现分隔符的地方都需要\emph{统一}。</p>
                    
                <p>下面是一些例子，例如，若希望将当前行的<strong>第一个</strong>“hello”替换为“bye”，则需要命令<code>:s/hello/bye/</code>，若希望对所有字符串进行替换，则使用<code>:s/hello/bye/g</code>。</p>
                    
                <p>若希望对第一行到第三行的所有“hello”进行替换，则使用<code>:1,3s/hello/bye/g</code>，若没有最后的<code>g</code>，则表示仅对<strong>第一行到第三行每一行里面的第一个字符串进行替换</strong>。</p>
                    
                <p>如果希望对第一行到最后一行的所有“hello”进行替换，则使用<code>:1,$s/hello/bye/g</code>。其中，<code>$</code>表示<strong>最后一行</strong>。</p>

                <div class="attention">
                    <p>在vi当中，数字可以具有<strong>重复若干次</strong>的含义。例如，在前面所介绍的<code>x</code>表示删除当前光标所在字符，若前面加上一个数字，则表示重复这一操作多少次（即删除多少字符），例如，<code>10x</code>表示删除10个字符。</p>

                    <p>同时，在vi当中，往往使用<code>$</code>表示<strong>最后</strong>的意思。例如，在普通模式下直接输入<code>$</code>则直接跳转到<strong>这一行最后一个字符</strong>，类似的，输入<code>0</code>则跳转到这一行第一个字符。输入<code>:$</code>可以直接跳转到文件最后一行。</p>
                </div>
                
                <h3 id="subsec:查找与替换-错误处理">错误处理</h3>

                <h4>查找（替换）完之后字符串总是高亮显示，怎么将其关闭</h4>

                <p>使用<code>:noh</code>命令。</p>

                <h4>E488: Trailing characters</h4>

                <p>这可能是在输入命令时使用了错误的格式。请仔细检查使用的命令（尤其是替换命令）的格式。</p>
                
                <h4>想要替换，却发现把光标上的字符删除了</h4>

                <p>这是因为在使用替换命令时，前面需要有冒号<code>:</code>。若没有添加这一符号，直接使用<code>s</code>则意味着<strong>删除当前字符并插入</strong>。</p>
        </div>
        <div id="linuxRegex" class="chapter-content" style="display: none;">
            <h2>2.4 初窥正则表达式</h2>
            <p><strong>作者：</strong> Jiaqi Z.</p>

            <h3>知识点</h3>
            <ul>
            <li>什么是正则表达式</li>
            <li>如何使用简单的正则表达式进行查找和替换</li>
            </ul>
            
            <h3 id="subsec:初窥正则表达式-关于正则表达式">关于正则表达式</h3>

            <p>在<a href="#linuxFindReplace">查找与替换</a>一节当中，我们提到过，vi的查找和替换相比于其他文本编辑器都稍显复杂。而这一节所介绍的<strong>正则表达式</strong>，则是其十分强大的功能之一。</p>

            <p>简单来说，正则表达式是<strong>一种用于匹配和操作文本的强大工具，它是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本模式</strong>。借助于正则表达式，我们可以很方便对许多具有相同模式的字符串进行匹配与处理。例如，对于<code>ENCUT=200</code>和<code>ENCUT=400</code>，从字符串本身来看是不同的，但二者具有相同的模式（<code>ENCUT=</code>加上一系列整数字符）。因此，可以使用正则表达式进行批量处理。</p>

            <p>在Linux当中，正则表达式是相对比较复杂的内容。在这一节只是简单介绍一下基本用法，对于更完整的内容，将在后面章节进行介绍。</p>
            
            <h3 id="subsec:正则表达式-元字符">元字符</h3>

            <p>正则表达式最有特色的部分，就是可以使用<strong>元字符</strong>来匹配一系列特定的字符。在介绍一些复杂的元字符之前，先熟悉一个最简单的符号，<code>[]</code>，在中括号里面，可以放入一些字符。正则表达式将会<strong>匹配这些字符当中的一个</strong>。例如，对于字符串“hello”，使用正则表达式<code>[aeiou]</code>就可以匹配到字符串里面的所有元音字母。</p>

            <div class="attention">
                <p>在vi当中，可以使用正常的查找方式和替换方式，只不过需要在输入查找的内容时使用正则表达式。简单说，你可以将正则表达式看作是一个表达多个字符串集合的方式，而可以使用这种方式一次性对这个集合内的每一个元素进行查找和替换。这样的话，其使用方法就与普通的查找和替换基本无异了。</p>

                <p>同时，特别需要注意的一点是，在vi当中，有一些符号（后面会提到）与Linux本身的正则表达式不同（Linux的命令行本身也是支持正则表达式的），通常区别在于是否添加一个反斜杠（<code>\</code>）。后面遇到时会特别指出。</p>
            </div>

            <p>在上面的例子中，我们可以直接在vi当中直接使用<code>/[aeiou]</code>实现对所有元音字母的查找。</p>

            <p>在使用<code>[]</code>时，可以使用<code>-</code>对特定范围内的字符进行查找。例如，使用<code>[a-h]</code>表示对a到h之间的所有字母（小写字母）进行查找。常用的还有，使用<code>[A-Z]</code>表示对所有大写字母进行匹配，<code>[a-z]</code>表示对小写字母进行匹配，<code>[0-9]</code>表示对所有阿拉伯数字进行匹配。</p>

            <div class="extend">
                <p>也许你会有疑问：这个范围是按照什么排序的？在计算机当中，这些字符都是根据ASCII码将其转化为二进制存储在计算机内。因此，这里的排序也是根据每一个字符所对应的ASCII码排序的。</p>

                <p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本延伸美国标准信息交换码则可以部分支持其他西欧语言，并等同于国际标准ISO/IEC 646。</p>

                <p>ASCII 由电报码发展而来。第一版标准发布于1963年 ，1967年经历了一次主要修订，最后一次更新则是在1986年，至今为止共定义了128个字符；其中33个字符无法显示（一些终端提供了扩展，使得这些字符可显示为诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符。控制字符的用途主要是用来操控已经处理过的文字。在33个字符之外的是95个可显示的字符。</p>

                <p>例如，0的ASCII码为48，A的ASCII码为65，而a的ASCII码为97。因此，可以使用<code>[0-a]</code>匹配到大写字母<code>A</code>。</p>
            </div>

            <p>同时，中括号里面的字符是可以组合使用的，例如，可以使用<code>[A-Za-z]</code>表示所有的字母。那如果希望表达所有的字母和数字呢？</p>

            <strong>答案：</strong><code>[A-Za-z0-9]</code>

            <p>除此之外，对于一些常见的字符，为其设置了特殊的符号，例如，<code>\d</code>就表示<strong>所有的数字字符</strong>，<code>\w</code>表示<strong>所有的字母、数字和下划线</strong>，也就等价于<code>[A-Za-z0-9_]</code>。</p>

            <p>而在使用中括号时，也可以使用符号<code>^</code>进行<strong>反选</strong>。例如，使用<code>^[A-Z]</code>表示排除所有大写字母的字符。</p>
            
            <h3 id="subsec:初窥正则表达式-总结">总结</h3>

            <p>本节简单介绍了一些常见的元字符，并可以将其用于查找和替换。例如，在本节开头所介绍的<code>ENCUT=200</code>和<code>ENCUT=400</code>，使用正则表达式可以直接表示为：<code>ENCUT=\d\d\d</code><sup>1</sup>。</p>

            <p>正如最开始所说的那样，正则表达式的功能远不止此，对于更复杂的部分（例如，目前使用<code>[]</code>只能匹配一个字符，如何匹配多个字符？），将在后面的章节进行更加详细的介绍。</p>

            <h3 id="subsec:初窥正则表达式-错误处理">错误处理</h3>

            <h4>如何查找如<code>[hello]</code>这样的字符串？</h4>

            <p>在正则表达式当中，已经将中括号作为特殊符号使用。因此，如果想查找带有中括号的字符串，则需要将中括号前面添加一个反斜杠<code>\</code>表示中括号这一字符本身。例如，对于上面的例子，如果直接使用<code>[hello]</code>表示匹配这5个字母（实际为4个）当中的任意一个字符；而使用<code>\[hello\]</code>或者<code>\[hello]</code>都可以表示字符串“[hello]”</p>

            <footer>
                <p>注解：</p>
                <ol>
                <li id="ftnt1">事实上，它还有更简洁的表示方法<code>ENCUT=\d\+</code>，但碍于本节的内容，详细的含义将放在后面章节介绍。</li>
                <li id="ftnt2">脚注内容</li>
                </ol>
                </footer>
        </div>
        <div id="linuxWildcards" class="chapter-content" style="display: none;">
            <h2>3.1 通配符</h2>
            <p><strong>作者：</strong> Jiaqi Z.</p>

            <h3>知识点</h3>
            <ul>
            <li>什么是通配符</li>
            <li>如何使用通配符批量处理文件</li>
            </ul>

            <p>在Linux命令行操作一章当中，我们介绍了如何使用Linux的命令行进行简单的操作，如查看文件、对文件和目录进行操作等。同时，在文本编辑工具vi和vim一章，我们详细介绍了如何使用vi对文本文件进行编辑。对于绝大多数情况，以上两个章节的内容足够后续的计算任务了。</p>

            <p>但“人的本性终究是懒惰的”，在大多数时候，我们可能不希望打开vi后再使用<code>/</code>这样的命令来查找，而是希望直接在命令行查找我们需要的内容。进一步的，对于更多的文件，有时我们希望同时对这些文件的相同内容进行查找，这时在vi中操作就显得麻烦了。因此，在本章，我们会进一步讨论一些在命令行当中的“进阶操作”，主要是为了能够更方便的处理文件和数据。</p>

            <h3 id="subsec:通配符-关于通配符">关于通配符<code>*</code>, <code>?</code></h3>

            <p>通配符是一种特殊语句，主要有星号（<code>*</code>）和问号（<code>?</code>），用来<strong>模糊搜索</strong>。例如，当查找文件时，如果不知道真正的字符，或者希望匹配一系列具有相似模式的文件时，可以使用它来代替一个或多个真正字符。</p>

            <p>其中，<code>*</code>表示<strong>零个或多个任意字符</strong>。例如，使用<code>*.txt</code>表示文件名最后为<code>.txt</code>的所有文件，可以是<code>hello.txt</code>, <code>bye.txt</code>, <code>roselia.txt</code>等。</p>

            <div class="extend">
                <p>上面的例子实际上就是后缀名的表示方法。它并不是一个很新奇的事情，事实上，在Windows操作系统中，当你在打开或者保存文件时，都可以在下面的“文件类型”中看到这种使用通配符的表示方法（如图所示）</p>

                <p>同时，如果你“思维敏捷”的话，可能会联想到<a href="#linuxRegex">初窥正则表达式</a>一节所介绍的正则表达式。事实上，通配符在<strong>某种程度上</strong>也是正则表达式当中的一个特例。</p>

                <img src="fig/通配符.png" alt="通配符在Windows操作系统下的应用" width="100%">
            </div>

            <p>相对地，<code>?</code>表示<strong>零个或一个任意字符</strong>，例如，<code>he*o</code>可以匹配到<code>hello</code>，而<code>he?o</code>却不能（可以匹配到<code>helo</code>）</p>

            <h3 id="subsec:通配符-使用通配符进行文件目录操作">使用通配符进行文件目录操作</h3>

            <p>下面将会简单展示一下，如何使用通配符对文件进行“批量操作”。首先，一个最常见的例子是：批量删除文件。例如，假设当前目录下有<code>data1.dat</code>和<code>data2.dat</code>这样两个后缀名为<code>.dat</code>的文件，如果希望同时删除它们，按照原来的做法，则可能需要按照顺序执行两遍命令：<code>rm data1.dat</code>和<code>rm data2.dat</code>。而借助于通配符，可以只使用<code>rm *.dat</code>表示<strong>删除所有后缀名为<code>.dat</code>的文件</strong>。</p>

            <div class="attention">
                <p>在这一行命令里，通配符所表示的文件可以将其“展开”，等价于<code>rm data1.dat data2.dat</code>。</p>

                <p>另外，在命令行当中，通配符的优先级比较高，因此，如果一个文件本身含有符号<code>*</code>，则需要使用反斜线（<code>\</code>）进行转义，例如，<code>rm *</code>表示删除当前目录下文件名为<code>*</code>的文件。相反，使用<code>rm *</code>表示删除当前目录下所有文件（务必要小心这一命令）</p>
            </div>

            <p>同样，使用这一方法也可以批量复制文件，与删除类似，可以使用如<code>cp *.dat data</code>这样的命令将所有后缀名为<code>.dat</code>的文件复制到<code>data</code>目录下。</p>

            <p>正如前面所说的那样，这一命令可以将其展开成<code>cp data1.dat data2.dat data</code></p>

            <p>同样，上面对文件名的通配符使用也可以用于目录当中，例如，<code>rm */*.dat</code>表示删除当前目录下的子目录当中所有后缀名为<code>.dat</code>的文件。</p>

            <div class="attention">
                <code>*</code>虽然可以表示零个或多个任意字符，但却不能表示<strong>目录下的目录</strong>。例如，<code>rm */data</code>可以匹配到<code>1/data</code>, <code>2/data</code>但无法匹配到<code>1/1/data</code>这样更深一级的目录。
            </div>

            <p>关于使用<code>?</code>通配符的使用方法，其基本原理和使用<code>*</code>类似，这里不再举例。同时，你也应该意识到的是，上面的例子中，我们都是把通配符放在了开头或者结尾。不一定总是这样的，例如，完全可以使用如<code>hello*.txt</code>这样的方式表示如<code>hello.txt</code>, <code>hello1.txt</code>这样子的文件。</p>

            <div class="extend">
                <p>虽然这一套教程是关于Linux的，但在Windows当中，通配符同样十分强大。与我们通常使用Windows的方式不同，它通常是在命令提示符（cmd）当中使用的。如果你希望在Windows当中体验这一功能，可以在开始菜单搜索<code>cmd</code>（对于新版Windows操作系统也可以是更高级的<code>PowerShell</code>）。</p>

                <p>一些基本的操作语法与Linux类似，但有些操作可能有些许区别。例如，在Windows的命令行当中，使用<code>dir</code>查看当前目录下的文件，使用<code>del</code>删除文件，使用<code>copy</code>复制文件，使用<code>move</code>移动文件等<sup>1</sup>。因此，在Windows当中，可以使用如<code>del *.txt</code>这样的命令删除当前目录下所有后缀名为<code>.txt</code>的文件，使用<code>move *.jpg jpg</code>将当前目录下所有后缀名为<code>.jpg</code>的文件移动到<code>jpg</code>目录下。</p>

                <p>这种方式可以有效帮助你批量处理电脑中的文件。</p>
            </div>

            <h3 id="subsec:通配符-错误处理">错误处理</h3>

            <h4>rm: cannot remove &lt;路径名&gt;: No such file or directory</h4>

            <p>在<a href="#subsec:文件操作-错误处理">文件操作-错误处理</a>一节当中已经介绍了这一错误，但对于通配符的使用而言，这种错误更加常见。例如，上面的例子，当你试着使用通配符<code>*/*.dat</code>删除<code>1/1/data.dat</code>文件时，由于无法匹配到对应的文件，因此则会报出这一错误。</p>

            <h4>cp: cannot stat &lt;路径名&gt;: No such file or directory</h4>

            <p>这一错误与上面的错误类似，都是由于文件不存在所导致的。对于使用通配符的情况，请仔细检查文件名是否正确。</p>

            <footer>
                <p>注解：</p>
                <ol>
                <li id="ftnt1">对于cmd命令的完整操作，可以使用cmd下的<code>help</code>命令查看。</li>
                </ol>
                </footer>
        </div>
        <div id="linuxGrep" class="chapter-content" style="display: none;">
            <h2>3.2 grep匹配字符串</h2>
            <p><strong>作者：</strong> Jiaqi Z.</p>

            <h3>知识点</h3>
            <ul>
            <li>如何使用<code>grep</code>查找文件中的字符串</li>
            </ul>

            <p>在<a href="#sec:查找与替换">查找与替换</a>一节当中，已经详细介绍了如何在vi当中进行查找和替换。正如本章一开始所说的那样，很多时候我们希望在不打开vi的前提下直接找到我们所需要的信息。或者我们希望能够在一系列类似的文件中查找同样的内容<sup>1</sup>，在命令行下借助于<a href="#sec:通配符">通配符</a>一节所介绍的内容，可以很容易实现这一点。</p>

            <p>因此，本节我们需要了解如何在命令行当中直接查找特定字符串。同时，我们还将再一次“复习”关于正则表达式的内容（暂时只会用到<a href="#sec:初窥正则表达式">初窥正则表达式</a>一节所介绍过的内容）。</p>

            <h3 id="subsec:grep匹配字符串-使用grep查找字符串">使用<code>grep</code>查找字符串</h3>

            <p>在Linux当中，查找文本内容的常见命令是<code>grep</code>，其基本语法为：<code>grep [匹配的内容] [文件名]</code>，其中<code>[匹配的内容]</code>是要查找的<strong>正则表达式</strong>，而<code>[文件名]</code>则是希望查找的文件。</p>

            <div class="attention">
                <p>虽然说查找的是<strong>正则表达式</strong>，但实际上直接输入一个普通的字符串也是可行的。此时查找的内容就是普通的字符串查找。</p>

                <p>同时，查找的文件可以有多个，甚至可以使用通配符。若没有提供文件名，<code>grep</code>将会从<strong>标准输入</strong><sup>2</sup>中读取内容。</p>
            </div>

            <p>例如，使用<code>grep ENCUT INCAR</code>就可以查找在<code>INCAR</code>文件下所有<code>ENCUT</code>。</p>

            <p>同时，还可以使用<code>-r</code>参数<strong>递归搜索目录下的所有文件</strong>。例如，<code>grep -r ENCUT .</code>表示在当前目录下递归搜索<code>ENCUT</code>字符串。</p>

            <p>除此之外还有其他选项。例如，使用<code>-v</code>表示<strong>查找不匹配的行</strong>。例如，<code>grep -v ENCUT INCAR</code>表示打印<code>INCAR</code>文件中所有没有<code>ENCUT</code>的行；<code>-i</code>表示忽略大小写匹配；<code>-n</code>表示显示行号输出；<code>-l</code>表示只打印匹配的文件名。</p>

            <p>其中多数选项都是可以混用的，例如，<code>grep -l -r ENCUT .</code>表示什么含义？</p>

            <p><strong>答案：</strong>递归查找当前目录下所有含有<code>ENCUT</code>的文件，并只输出文件名。</p>

            <h3 id="subsec:grep匹配字符串-在grep当中使用正则表达式">在<code>grep</code>当中使用正则表达式</h3>

            <p>在<code>grep</code>当中，使用正则表达式有两个地方：<strong>查找内容</strong>和<strong>文件名</strong>。关于文件名，大多数内容都如同<a href="#sec:初窥正则表达式">初窥正则表达式</a>一节和<a href="#sec:通配符">通配符</a>一节所介绍的那样，例如，使用<code>grep ENCUT */INCAR</code>表示查找当前目录所有子目录下名为<code>INCAR</code>的文件当中含有<code>ENCUT</code>的行。</p>

            <p>除此之外，在查找的内容当中，也可以使用正则表达式，此时的用法就完全类似于在vi当中使用正则表达式进行查找（见<a href="#sec:初窥正则表达式">初窥正则表达式</a>）。</p>

            <h3 id="subsec:grep匹配字符串-错误处理">错误处理</h3>

            <h4>grep: &lt;路径名&gt;: Is a directory</h4>

            <p>这表示你尝试在目录当中查找字符串，这显然是行不通的。如果你希望查找这一路径下所有文件，可以使用<code>grep -r &lt;字符串&gt; &lt;目录名&gt;</code>或者<code>grep &lt;字符串&gt; &lt;目录名&gt;/*</code>。</p>


            <footer>
                <p>注解：</p>
                <ol>
                <li id="ftnt1">这在后续VASP批量处理中可能十分有用，例如，我们希望查找所有<code>INCAR</code>文件当中的<code>ENCUT</code>设置情况，就需要这个方法。</li>
                <li id="ftnt2">从终端、键盘输入</li>
                </ol>
                </footer>
        </div>

        <div id="sec:sed文本替换" class="chapter-content" style="display: none;">
            <h2>sed文本替换</h2>
            <p><strong>作者：</strong> Jiaqi Z.</p>

            <h3>知识点</h3>
            <ul>
            <li>如何使用<code>sed</code>命令对文本文件进行替换</li>
            <li>如何使用<code>sed</code>查看文件内容</li>
            <li>如何使用<code>sed</code>添加（删除）文本文件的内容</li>
            </ul>

            <p>在<a href="#sec:查找与替换">查找与替换</a>当中，已经介绍了如何使用vim进行文本文件的替换。与vi里面的<code>s</code>命令类似，在命令行也有类似的方式可以对文本文件进行替换（甚至更复杂的操作）。那就是使用<code>sed</code>命令。</p>

            <h3 id="subsec:sed文本替换-使用sed显示">使用<code>sed</code>显示</h3>

            <p><code>sed</code>的语法格式是：<code>sed [选项] "&lt;动作&gt;" [文件路径]</code>。其中，常见的选项包括</p>

            <ul>
                <li><code>-n</code> 表示<strong>只有处理的文本</strong>显示在屏幕上（默认是全部文本）</li>
                <li><code>-i</code> 表示<strong>直接修改文件内容</strong></li>
            </ul>

            <div class="attention">
                <p>在本节，我们所处理的文件都会使用<code>-i</code>选项直接对文件进行处理。但这一行为是危险的，尤其是对于不确定的修改操作，由于它是对原文件进行修改，因此需要提前备份。此外，千万不要将<code>-n</code>和<code>-i</code>结合起来使用，它表示<strong>仅将处理的文本修改为文件内容</strong>。</p>

                <p>在下一节将介绍管道运算符和重定向运算符，将会帮助你避免这一问题。</p>
            </div>

            <div class="extend">
                <p>如果你仔细观察上面的语法格式，需要特别注意的是里面的<code>[文件路径]</code>是“可选”的，也就是说，<strong>对于<code>sed</code>命令而言，可以不提供文件路径</strong>。这件事可能会比较“难以置信”，毕竟如果没有文件，怎样处理文件呢？</p>

                <p>事实上，<code>sed</code>命令是一个<strong>管道命令</strong>，简单来说，它是可以读取并处理终端输出的内容。除此之外，像前面的<code>grep</code>也是类似的（虽然我们前面并没有特别强调这一点）。</p>

                <p>在下一节，我们将详细讨论管道命令的内容。</p>
            </div>

            <p>让我们先来看一个最简单的操作——<strong>打印</strong>，即试着将特定几行的内容打印在屏幕上。其在“动作”部分的写法是<code>&lt;开始行号&gt;,&lt;结束行号&gt;p</code>。例如，我们希望将<code>POSCAR</code>的第3-5行输出，可以使用命令<code>sed -n "3,5p" POSCAR</code>表示输出第3-5行内容。</p>

            <div class="extend">
                <p>如果你此时忘记了<code>-n</code>选项的话，命令将会输出所有的<code>POSCAR</code>文件，但对应行号的内容会重复输出。（可以试试）</p>

                <p>另外，如果希望对最后一行进行操作，需要使用<code>$</code>符号表示<strong>最后一行</strong>，但此时<strong>需要将外面的双引号变为单引号</strong>。通常情况下，双引号和单引号是等价的，但在涉及到<code>$</code>符号时，使用双引号则表示将<code>$</code>和后面的符号（例如<code>$p</code>）解析成<strong>变量p</strong>，而使用单引号则表明这一符号就是符号本身。变量的作用，将在后面循环和批量处理中体现，在此不做讨论。</p>
            </div>

            <h3 id="subsec:sed文本替换-使用sed添加和删除">使用<code>sed</code>添加和删除</h3>

            <p>使用<code>sed</code>命令删除某一行的方法是使用<code>d</code>，例如，如果希望删除<code>POSCAR</code>文件的第3-5行，类似于上面的显示，使用方法是<code>sed -n "3,5d" POSCAR</code></p>

            <div class="attention">
                <p>这一操作是对文件内容进行删除，因此你应该谨慎使用<code>-i</code>选项（会直接将原文件对应内容删除），在下一节的重定向运算符将会提供灵活的解决方法。目前的一个方法是<strong>创建一个备份文件</strong>。</p>
            </div>

            <p>对于添加某行内容，可以使用<code>a</code>或<code>i</code>，前者表示<strong>新增（在下一行）</strong>，后者表示<strong>插入（在上一行）</strong>。具体的，其命令为：<code>sed [选项] "行号a(i) 添加字符串" [文件名]</code>例如，希望在<code>POSCAR</code>的第一行后面添加一个字符串“1.0”，可以使用<code>sed -n "1a 1.0" POSCAR</code>。</p>

            <p>那么，如果希望在第一行添加内容，应当怎么办呢？</p>

            <strong>答案：</strong><code>sed -n "1i 1.0" POSCAR</code>即可。

            <h3 id="subsec:sed文本替换-使用sed替换">使用<code>sed</code>替换</h3>

            <p>使用<code>sed</code>替换有两种模式，分别是<strong>整行替换</strong>和<strong>字符串替换</strong>。对于整行替换，命令为<code>sed [选项] "行号c 替换目标字符串" [文件名]</code>。例如，若希望将<code>POSCAR</code>的第2行替换为“0.8”，则可以使用命令：<code>sed -n "2c 0.8" POSCAR</code>。</p>

            <p>相比于整行替换，字符串替换可能更为强大。与vim的替换类似，在<code>sed</code>当中替换字符串的命令是<code>sed [选项] "s/要被替换的字符串/新字符串/g"</code>。例如，希望在<code>INCAR</code>当中的<code>ENCUT=400</code>替换为<code>ENCUT=600</code>，可以使用命令<code>sed "s/ENCUT=400/ENCUT=600/g" INCAR</code>。</p>

            <p>对于字符串替换而言，更重要的是<strong>支持正则表达式</strong>（关于正则表达式的内容详见<a href="#sec:初窥正则表达式">初窥正则表达式</a>一节），例如，在上面的例子中，我们希望将<code>ENCUT=400</code>或<code>ENCUT=600</code>全部替换为<code>ENCUT=800</code>，则可以使用<code>sed "s/ENCUT=\d\d\d/ENCUT=800/g" INCAR</code></p>

            <div class="attention">
                <p>同样，由于这是对内容的删除（更改），因此需要提前备份。除非有足够的把握，否则不要使用<code>-i</code>选项。</p>
            </div>


            <h3 id="subsec:sed文本替换-错误处理">错误处理</h3>

            <h4>sed: -e expression #1, char 2: invalid usage of line address 0</h4>

            <p>在使用行号时，第一行是1而不是0. 通常来说，当你试图在第1行插入数据时，应当使用<code>sed -n "1i 字符串" [文件名]</code>，其中<code>i</code>表示在第1行前面插入数据（即在第一行写入字符串）</p>
        </div>

        <div id="sec:管道与重定向" class="chapter-content" style="display: none;">
            <h2>管道与重定向</h2>
            <p><strong>作者：</strong> Jiaqi Z.</p>

            <h3>知识点</h3>
            <ul>
            <li>管道运算符、如何使用管道运算符连接多个命令</li>
            <li>使用重定向写入（读取）文本文件</li>
            </ul>

            <h3 id="subsec:管道与重定向-管道">管道</h3>

            <p>在<a href="#sec:sed文本替换">sed文本替换</a>一节当中，我们讨论了如何使用<code>sed</code>命令对文本文件进行编辑。当时我们提到，<code>sed</code>命令是一个管道命令，可以读取终端输出的内容。除此之外，在很多时候我们希望对某一文件进行多次操作，例如，提取某一文件的前10行，并将其中的“C”改成“B”，然后再写入新的文件当中。</p>

            <p>像上面这种输入和输出层层传递的（一个命令的输出作为另一个命令的输入），就可以使用这一节的“管道”命令。在Linux当中，管道运算符是<code>|</code>（通常是Shift+Backspace下面的那个键），它的作用是<strong>把前面命令的输出作为下一个命令的参数输入</strong>。例如，我们希望将<code>POSCAR</code>输出，可以使用<code>cat POSCAR</code>，若此时又想取出前5行，则可以使用<code>cat POSCAR | head -n 5</code></p>

            <div class="attention">
                <p>也许使用<code>head -n 5 POSCAR</code>一样可以解决上述问题，但使用管道更具有“可扩展性”。例如，<code>cat</code>命令本意是将多个文件连接起来，若希望将连接之后的文件读取前5行，则使用管道运算符是最简单的方法之一。</p>
            </div>

            <p>上面的过程，可以看作是将<code>cat</code>命令输出结果作为<code>head</code>命令的参数输入，之后运行<code>head</code>命令并输出（至标准输出），进一步，如果我们希望将其中的“C”全部替换成“B”，则需要借助于<code>sed</code>命令，表示为：<code>cat POSCAR | head -n 5 | sed "s/C/B/g"</code></p>

            <div class="attention">
                <p>此时使用<code>sed</code>命令由于没有添加<code>-i</code>选项，因此结果也仅仅在标准输出当中进行输出，源文件并没有修改。</p>
            </div>

            <p>类似地，如果我们希望得到<code>OUTCAR</code>最后一个包含“without”字符串的行，在使用管道之前是“几乎不可能”的，而在利用管道时，便可以使用命令：<code>grep without OUTCAR | tail -n 1</code>得到结果<sup>1</sup>。</p>

            <h3 id="subsec:管道与重定向-输出重定向与输入重定向">输出重定向与输入重定向</h3>

            <p>在之前，我们得到的输出结果仅仅是在屏幕上输出（也被称为“标准输出”），但必要的时候，我们也希望将结果保存至本地，以便后续处理（无论是进一步使用程序语言读取并处理，还是过一段时间再看）。正因如此，寻找一种方法将输出结果保存就十分重要。</p>

            <p>在Linux当中，保存终端输出的本质就是“将输出<strong>重定向</strong>至文件”，其运算符是<code>&gt;</code>或<code>&gt;&gt;</code>，后面需要有一个文件名路径表示<strong>希望写入的文件</strong>。其中，前者（<code>&gt;</code>）表示<strong>创建</strong>，当文件存在时则会覆盖；后者（<code>&gt;&gt;</code>）表示<strong>追加</strong>，当文件不存在时新建，存在时则会在后面追加新的内容。</p>

            <p>有了这一方法，我们终于可以解决<a href="#sec:sed文本替换">sed文本替换</a>一节所遗留的关键问题：如何将编辑后的文件保存至新的文件？答案就是<strong>使用重定向运算符</strong>。例如，我们希望将<code>INCAR</code>文件里面的<code>ENCUT=400</code>改为<code>ENCUT=600</code>并保存至<code>INCAR2</code>，则可以使用命令：<code>sed "s/ENCUT=400/ENCUT=600/g" INCAR &gt; INCAR2</code></p>

            <p>再一个例子，如果希望将<code>Si/POTCAR</code>和<code>O/POTCAR</code>合并至一个新的<code>POTCAR</code>当中，应当怎样写呢？</p>

            <strong>答案：</strong><code>cat Si/POTCAR O/POTCAR &gt; POTCAR</code>

            <div class="extend">
                <p>请注意运算符是<code>&gt;</code>而不是<code>&lt;</code>，前者表示“输出重定向”，而后者表示“输入重定向”，即将文件的内容作为命令的输入。例如，<code>cat &lt; POSCAR</code>与<code>cat POSCAR</code>等价。</p>

                <p>二者的方向虽然容易混淆，但似乎可以从箭头的方向看出一点规律——<code>&gt;</code>表示将命令的内容“输出至”文件中，而<code>&lt;</code>表示将文件“输入至”命令中。</p>
            </div>

            <p>在必要的时候，我们当然也可以将输入和输出同时重定向，例如，<code>cat &lt; POSCAR &gt; POSCAR2</code>也是可行的（将<code>POSCAR</code>重定向输入至<code>cat</code>命令，并将命令输出结果重定向至<code>POSCAR2</code>输出）</p>

            <div class="extend">
                <p>除了“标准输入”和“标准输出”之外，Linux还有一个“标准错误输出”，用来输出命令运行报错的结果。例如，当我们希望删除一个名为<code>POSCUT</code>的文件时（该文件并不存在），使用<code>rm POSCUT</code>会报错（这一点在<a href="#sec:文件操作">文件操作</a>已经详细讨论过了）。如果试图将这一输出重定向，例如，<code>rm POSCUT &gt; output</code>，效果是一样的。但如果使用<code>rm POSCUT 2&gt; output</code>呢？你会发现，终端没有报错了，而将报错输出至文件<code>outcar</code>当中了。这其中，<code>2&gt;</code>就表示将“标准错误输出”重定向至后面的文件。</p>

                <p>在这一基础上，稍微扩展一下。在后面的VASP教程中，我们将看到提交脚本中有<code>mpirun vasp_std &gt; vasp.out 2&gt;vasp.err</code>这一行<sup>2</sup>。暂且忽略掉前面的<code>mpirun</code>（表示分布式计算系统下并行运行任务），可以发现，这一行的作用就是运行<code>vasp_std</code>，并将输出结果输出至<code>vasp.out</code>，而将错误信息输出至<code>vasp.err</code>。</p>

                <p>另外，我们这里重定向的文件并不一定是文本文件。如果你回顾一下<a href="#subsec:查看文件-Linux文件类型">查看文件-Linux文件类型</a>一节，可能会发现里面有一个“设备文件”，它也是可以作为重定向输入输出的一部分。例如，<code>rm POSCUT 2&gt; /dev/null</code>则表示将输出报错信息重定向至<code>/dev/null</code>设备（这是一个“空设备”，用于消除所输出的内容）。运行这一命令，你将不会得到任何输出结果（输出被消除了）</p>
            </div>

            <h3 id="subsec:管道与重定向-错误处理">错误处理</h3>

            <h4>使用<code>cat &lt;&lt; POSCAR</code>没有反应</h4>

            <p>如果你确实希望使用输入重定向，应当注意是<code>&lt;</code>（一个）而不是<code>&lt;&lt;</code>（两个）。后者在Linux中通常用于终端交互中，例如，上面的命令表示将<code>POSCAR</code>之间的内容作为输入。一个演示例子为：</p>

            <pre><code class="bash">
$ cat &lt;&lt; POSCAR
&gt; hello
&gt; world
&gt; POSCAR
hello
world
            </code></pre>

            <p>可以看到，它把“POSCAR”之间的内容传入了<code>cat</code>命令（输出）</p>

            <footer>
                <p>注解：</p>
                <ol>
                <li id="ftnt1">这一过程实际上是在VASP当中得到最后收敛能量的过程。</li>
                <li id="ftnt2">不同课题组可能有所不同，这里仅仅作为例子。</li>
                </ol>
            </footer>
        </div>

        <!-- 更多章节内容 -->
        <div id="sec:什么是声子、声子谱" class="chapter-content" style="display: none;">
            <h2>什么是声子、声子谱</h2>
            <p><strong>作者：</strong>Isay K.<p>

                <h3>知识点</h3>
                <ul>
                <li>声子</li>
                <li>声子谱</li>
                </ul>
                
            <h3 id="subsec:什么是声子、声子谱-声子">声子</h3>
            
            <p>声子（Phonon），即“晶格振动的简正模能量量子”，是晶体中<strong>原子振动</strong>的量子化描述。</p>

            <p>在固体物理学中，声子是晶格振动的准粒子，其携带能量和动量，并且可以像粒子一样进行相互作用。</p>

            <p>声子是<strong>简谐近似</strong>下的产物，如果振动太剧烈，超过小振动的范围，那么晶格振动就要用非简谐振动理论描述。</p>

            <p>声子并不是一个真正的粒子，声子可以产生和湮灭，有相互作用的声子数不守恒，声子动量的守恒律也不同于一般的粒子，并且声子不能脱离固体存在。声子只是格波激发的量子，在多体理论中称为集体振荡的元激发或准粒子。</p>

            <p>声子的化学势为零，属于<strong>玻色子</strong>，服从玻色-爱因斯坦统计。声子本身并不具有物理动量，但是携带有准动量，并具有能量，它的能量等于<math xmlns="http://www.w3.org/1998/Math/MathML"><mi data-mjx-alternate="1">ℏ</mi><msub><mi>ω</mi><mi>q</mi></msub></math>。</p>

            <p>声子可以分为以下两类：
            <ul>
                <li>声学支：与晶格的纵向和横向振动相关，类似于声波，表示原胞的整体振动。</li>
                <li>光学支：与晶格的非均匀振动相关，通常与电荷的重新分布有关，表示原胞内原子间的相互振动。</li>
            </ul>
            </p>

            <p>如果一个材料的原胞中有<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math>个原子，那么声子谱就会有<math xmlns="http://www.w3.org/1998/Math/MathML"><mn>3</mn><mi>N</mi></math>支，其中3条声学支，<math xmlns="http://www.w3.org/1998/Math/MathML"><mn>3</mn><mi>N</mi><mo>−</mo><mn>3</mn></math>条光学支。</p>

            <h3 id="subsec:什么是声子、声子谱-声子谱">声子谱</h3>

            <p>声子谱，也称为声子色散关系，是描述声子能量与动量之间关系的图表。</p>

            <p>声子谱通常在第一布里渊区内绘制，因为其包含了所有可能的声子模式。</p>

            <p>通常，使用声子谱研究体系的动力学稳定性，使用分子动力学研究体系的热力学稳定性。</p>

            <p>声子谱的其他物理意义：
            <ul>
                <li>电子-声子耦合：在半导体和超导体中，电子-声子耦合相互作用对材料的电子性质至关重要；</li>
                <li>声子散射：在金属和半导体中，声子散射是影响电子迁移率的关键因素；</li>
                <li>热容：声子谱可以解释材料在不同温度下的热容行为</li>
                <li>...</li>
            </ul></p>
        </div>
        <div id="sec:计算方法简介" class="chapter-content" style="display: none;">
            <h2>计算方法简介</h2>
            <p><strong>作者：</strong>Isay K.<p>

            <h3>知识点</h3>
            <ul>
            <li>密度泛函微扰理论（DFPT）</li>
            <li>有限位移法（Finite Displacement Method）</li>
            <li>适用情境比较</li>
            </ul>
            
            <h3 id="subsec:计算方法简介-密度泛函微扰理论（DFPT）">密度泛函微扰理论（DFPT）</h3>

            <p>DFPT是一种基于第一性原理的方法，它直接从周期性边界条件的Kohn-Sham波函数计算出声子谱。在DFPT中，通过计算原子间相互作用的微扰来得到力常数矩阵，这是描述晶格动力学性质的关键量。</p>

            <div class="extend">
                1987年，Baroni、Giannozzi和Testa提出了一种新的晶格动力学性质计算方法--微扰密度泛函方法(Density Function Perturbation Theory)。DFPT通过计算系统能量对外场微扰的响应来求出晶格动力学性质。该方法最大的优势在于它不限定微扰的波矢与原胞边界(super size)正交，不需要超原胞也可以对任意波矢求解。因此可以应用到复杂材料性质的计算上。此外，能量对外场微扰的响应不仅可以推导出声子的晶体性质，还能求出弹性系数、声子展宽、拉曼散射截面等性质,这种方法本身就能算出Born effective charge dielectric constant,可以很好的预言LO-TO splitting甚至Kohn anomalies。这些优势使得DFPT一经提出就被广泛应用到了半导体、金属和合金、超导体等材料的计算上。比较常用的程序是pwscf和abinit，castep等采用的是一种linear response theory 的方法（或者称为  density perturbation functional theory，DFPT），直接计算出原子的移动而导致  的势场变化，再进一步构造出动力学矩阵。
            </div>

            <h3 id="sec:计算方法简介-有限位移法（Finite Displacement Method">有限位移法（Finite Displacement Method）</h3>
            
            <p>有限位移法通过在超原胞中引入原子的有限位移来模拟晶格振动。这种方法基于位移-响应理论，通过计算原子位移后系统的受力来构造动力学矩阵</p>

            <div class="extend">
                直接法，或称frozen-phonon方法，是通过在优化后的平衡结构中引入原子位移，计算作用在原子上的Hellmann-Feynman力，进而由动力学矩阵算出声子色散曲线。用该方法计算声子色散曲线最早开始于80年代初，由于计算简便，不需要特别编写的计算程序，很多小组都采用直接法计算材料性质。直接法的缺陷在于它要求声子波矢与原胞边界(super size)正交，或者原胞足够大使得Hellmann-Feynman力在原胞外可以忽略不计。这使得对于复杂系统，如对称性高的晶体、合金、超晶格等材料需要采用超原胞。超原胞的采用使计算量急剧增加，极大的限制了该方法的使用。这种方法不能很好的预言LO-TO splitting,只有在计算了Born effective charge和dielectric constant之后，进一步考虑了non-analyticity term，才能计算出；但Direct Method本身并不能给出Born effective charge和dielectric constant，所以这也是它的一个缺陷。
            </div>

            <h3 id="subsec:计算方法简介-适用情境比较">适用情境比较</h3>
            <p>DFPT适用情境：
                <ul>
                    <li>需要高精度声子谱的系统，尤其是小到中等大小的晶胞；</li>
                    <li>研究者希望避免有限位移法可能引入的系统误差时。</li>
                </ul></p>
                
            <div class="attention">
                DFPT方法计算成本较高，尤其对于大晶胞或高对称点附近的计算。
            </div>

            <p>有限声子法适用情境：
                <ul>
                    <li>当计算资源有限或需要对多种材料进行筛选时；</li>
                    <li>对于大晶胞材料的初步声子谱分析。</li>
                </ul></p>

            <p>总得来说，对于较重的任务，DFPT方法可能会造成内存溢出，且DFPT方法由于其特性而无法进行并行计算，而有限声子法可以并行。对于较小的体系，可以根据需要和组内资源选择方法。</p>

            <div class="extend">
                <p>建议优先使用有限位移法。</p>

                <p>一些教程中有时候将有限位移法又称为冷冻声子法或直接法。
                    但笔者并没有找到更官方的资料说明有限位移法和冷冻声子法是同一种方法，谨奉上<a href="https://phonopy.github.io/phonopy/index.html">PHONOPY官网</a>供读者自行分辨。</p>
            </div>

            <p>参考：<a href="http://muchong.com/html/200802/723527.html">http://muchong.com/html/200802/723527.html</a></p>
        </div>
        <div id="sec:计算软件PHONOPY" class="chapter-content" style="display: none;">
            <h2>计算软件PHONOPY</h2>
            <p><strong>作者：</strong>Isay K.<p>

            <h3>知识点</h3>
            <ul>
            <li>开始安装之前</li>
            <li>PHONOPY快速安装</li>
            <li>PHONOPY使用方法</li>
            </ul>

            <h3 id="subsec:计算软件PHONOPY-开始安装之前">开始安装之前</h3>

            <p>由于本教程面向的群体是计算小白（包括笔者也是通过本教程记录一下自己掉的坑），所以在开始安装软件之前，我们强烈建议先咨询组内老师或师兄师姐：服务器上是否已经配置了相应的软件？</p>

            <div class="extend">
                当然也可以使用 module avail 命令自己检查系统内已安装的软件，如果没有找到的话再咨询更有自主性哦。
                <img src="fig/module-check.png" alt="检查是否含有所需软件" width="100%">
            </div>

            <p>通常情况下，组内服务器的<strong>根目录</strong>下已经配置了相应的软件，这个时候再在自己的<strong>用户目录</strong>下进行配置的话，一方面在使用过程中可能会出现命令的冲突，另一方面也是一种时间、精力和资源的浪费。</p>

            如果组内确实并没有安装，或者你是传说中的开山大弟子，又或者是自学，请放心进入<a href="#subsec:计算软件PHONOPY-PHONOPY快速安装">PHONOPY快速安装</a>小节。

            <h3 id="subsec:计算软件PHONOPY-PHONOPY快速安装">PHONOPY快速安装</h3>

            参考：<a href="https://blog.csdn.net/qq_41866202/article/details/124407208?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ECtr-1-124407208-blog-139391379.235%5Ev43%5Epc_blog_bottom_relevance_base9&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ECtr-1-124407208-blog-139391379.235%5Ev43%5Epc_blog_bottom_relevance_base9&utm_relevant_index=1">https://blog.csdn.net/qq_41866202/article/details/124407208?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ECtr-1-124407208-blog-139391379.235%5Ev43%5Epc_blog_bottom_relevance_base9&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ECtr-1-124407208-blog-139391379.235%5Ev43%5Epc_blog_bottom_relevance_base9&utm_relevant_index=1</a>

            <h3 id="subsec:计算软件PHONOPY-PHONOPY使用方法">PHONOPY使用方法</h3>

            <h4>加载PHONOPY环境</h4>

            <p>
                <ol>
                    <li>加载Anaconda应用：<code>module load conda</code></li>
                    <li>激活PHONOPY环境：<code>conda activate PHONOPY</code></li>
                </ol>
            </p>

            <h4>命令详解</h4>

            <p>进入下面的官网之后点击Command options即可看到所有功能。</p>

            <a href="https://phonopy.github.io/phonopy/index.html ">https://phonopy.github.io/phonopy/index.html </a>

            <div class="attention">
                <p>在进行扩胞时的标准是：扩胞后的原子达到80~100个，每个晶轴方向大于10，不然得到的声子谱中很容易出现虚频。</p>
            </div>
        </div>
        <div id="sec:具体计算步骤" class="chapter-content" style="display: none;">
            <h2>具体计算步骤</h2>
            <p><strong>作者：</strong>Isay K.<p>

            <h3>知识点</h3>
            <ul>
            <li>计算声子谱前的结构优化</li>
            <li>DFPT方法计算声子谱</li>
            <li>有限位移法计算声子谱</li>
            </ul>

            <h3 id="subsec:具体计算步骤-计算声子谱前的结构优化">计算声子谱前的结构优化</h3>

            <div class="attention">
                <p>在计算声子时需要先对原胞结构做高精度的结构优化，不然得到的声子谱中很容易出现虚频。</p>
            </div>

            <p>我们以TiTe<sub>2</sub>为例，以下是高精度优化的具体参数。</p>
<h4>INCAR</h4>
            <pre><code>
Global Parameters
ISTART =  1
ISPIN  =  1
LREAL  = .FALSE.
ENCUT  =  380

LWAVE  = .FALSE.
LCHARG = .FALSE.
ADDGRID= .TRUE.
LASPH  = .TRUE.
PREC   = Accurate
NCORE = 8 
ISYM = 0

Lattice Relaxation
NSW    =  300
ISMEAR =  0
SIGMA  =  0.03
IBRION =  2
ISIF   =  3
IOPTCELL = 1 0 0 1 1 0 0 0 0
EDIFF = 1E-08
EDIFFG = -1E-03
            </code></pre>

            <p>为了保证优化精度足够高，其中需要注意的是：
                <ol>
                <li><code>EDIFF</code>表示电子收敛标准，至少要取<code>1E-06</code>，体系小的话尽量取<code>1E-08</code>；</li>
                <li><code>EDIFFG</code>取负值时表示力收敛标准，取\<code>1E-03</code>；</li>
                <li><code>ADDGRID</code>表示是否添加额外网格提高精度，设定为<code>.TRUE.</code>；</li>
                <li><code>PREC</code>表示“精度”模式，设定为<code>Accurate</code>（准确）；</li>
                <li><code>NSW</code>表示电子优化步数，取300防止计算中断；</li>
                <li><code>ENCUT</code>可以自行做测试，详见VASP计算-结构优化章节（先别去找，我没写）；</li>
            </ol>
            </p>

            <p>另外，其中<code>ISIF=3</code>表示既优化晶格又优化原子坐标，配合<code>IOPTCELL</code>可以实现晶轴的单独固定，以达到计算二维材料的目的，详见VASP计算-结构优化章节（也还没写）。</p>

            <p>下面的其他输入文件没有需要特别说明的，如有疑问请参考VASP计算-结构优化章节（哈哈，又是这）或参考VASP官网：<a href="https://www.vasp.at/wiki/index.php/The_VASP_Manual">https://www.vasp.at/wiki/index.php/The_VASP_Manual</a></p>
<h4>KPOINTS</h4>
            <pre><code>
A
0
Gamma
24   24   1
0.0  0.0  0.0  
            </code></pre>
<h4>POSCAR</h4>
            <pre><code>
TiTe2-1m1                               
1.00000000000000     
    3.7458432095936396   -0.0000184453725456    0.0000000000000000
    -1.8729216047968198    3.2439861579338527    0.0000000000000000
    0.0000000000000000    0.0000000000000000   18.0000000000000000
Ti   Te
    1     2
Direct
0.0000000000000000  0.0000000000000000  0.5127400160000022
0.6666666132020026  0.3333334158033583  0.6098496477195335
0.3333334157979960  0.6666666131966403  0.4156403382804701

0.00000000E+00  0.00000000E+00  0.00000000E+00
0.00000000E+00  0.00000000E+00  0.00000000E+00
0.00000000E+00  0.00000000E+00  0.00000000E+00 
            </code></pre>

            <p>提交任务进行计算，得到?<code>CONTCAR</code>为优化后的更合理的结构，作为后续声子计算的初始晶胞。
            （后续小节中提到“初始晶胞”均指优化后得到的晶胞，为避免歧义在此说明。）</p>

            <h3 id="subsec:具体计算步骤-DFPT方法计算声子谱">DFPT方法计算声子谱</h3>

            <p>1.<code>mkdir method_DFPT</code></p>

            <p>新建文件夹。</p>

            <p>2.<code>cp relax/CONTCAR method_DFPT/POSCAR</code></p>

            <p>将上一步高精度结构优化得到的<code>CONTCAR</code>复制进文件夹内，并重命名为<code>POSCAR</code>。</p>

            <p>3.<code>cd method_DFPT</code></p>

            <p>进入新文件夹。</p>

            <p>4.<code>module load conda</code>
            <code>conda activate phonopy</code></p>

            <p>加载<code>conda</code>模块，并激活<code>phonopy</code>环境，详情可参考<a href="#subsec:计算软件PHONOPY-PHONOPY使用方法">PHONOPY使用方法</a></p>

            <p>5.<code>phonopy -d --dim="6 6 1"</code></p>

            <p>使用PHONOPY进行6×6的扩胞。</p>

            <p>此时会产生数个名为<code>POSCAR-0？</code>的位移文件，以及名为<code>SPOSCAR</code>的扩胞后的结构。</p>

            <p>DFPT方法使用的是<code>SPOSCAR</code>，而有限位移法使用的是这些位移文件。</p>

            <div class="attention">
            <p>笔者研究的是2D结构，仅对两个方向进行扩胞，读者可根据需要自行调整。
            扩胞的标准是扩胞后达到80~100个原子，且晶轴长度大于10埃，不然得到的声子谱中很容易出现虚频。</p>
            </div>

            <p>6.<code>mkdir vasp-calculations</code></p>

            <p>新建文件夹用于后续计算。</p>

            <div class="extend">
            <p>此处根据个人习惯不同，也可以不新建文件夹。将<code>POSCAR</code>重命名为<code>POSCAR-unit</code>，将第5步新产生的<code>SPOSCAR</code>重命名为<code>POSCAR</code>，直接在当前文件夹中进行计算。</p>
            </div>

            <p>7.<code>cp SPOSCAR vasp-calculations/POSCAR</code></p>

            <p>将第5步新产生的<code>SPOSCAR</code>复制进文件夹，并重命名为<code>POSCAR</code>。</p>

            <p>8.准备其它基本文件：</p>
<h4>INCAR</h4>
            <pre><code>
SYSTEM = TiTe2
#ISIF = 3
NSW = 1
IBRION = 8

LWAVE = F
LCHARG = F

ENCUT = 380
EDIFF = 1E-8
EDIFFG =-1E-3
ISMEAR = 0

LREAL = F
SIGMA = 0.03

PREC = A
ADDGRID = .TRUE.
            </code></pre>

<h4>KPOINTS</h4>
<pre><code>
A
0
Gamma
3   3   1
0.0  0.0  0.0
</code></pre>

            <div class="attention">
                因为该计算使用的是扩胞之后的结构，所以K点没有必要取太大。
            </div>

            <p>9.<code>sbatch sub.vasp</code></p>

            <p>提交任务进行计算。</p>

            <p>10.<code>cd ..</code></p>

            <p>返回<code>method_DFPT</code>文件夹。</p>

            <p>11.<code>cp vasp-calculations/vasprun.xml .</code></p>

            <p>将<code>vasprun.xml</code>复制到当前文件夹。</p>

            <p>12.<code>phonopy --fc vasprun.xml</code></p>

            <p>使用phonopy读取<code>vasprun.xml</code>生成力常数文件<code>FORCE_CONSTANTS</code>。</p>

            <p>13.<code>vi band.conf</code></p>

            <p>编辑<code>band.conf</code>文件：</p>
<h4>band.conf</h4>
            <pre><code>
ATOM_NAME =Ti Te
DIM = 6 6 1
BAND =0 0 0  0.5 0 0  0.33333 0.33333 0   0 0 0
BAND_POINTS = 101
FORCE_CONSTANTS = READ
            </code></pre>
            
            <ol>
                <li> <code>DIM</code>根据体系的扩胞大小设置，如扩胞扩到332，就设置成<code>332</code>。</li>
                <li><code>BAND</code>和能带的取点是一样的，也可以用vaspkit生成。</li>
                <li><code>FORCE_CONSTANTS</code>一定设置成<code>READ</code>。</li>
                <li>更多设置可以看PHONOPY官网。</li>
            </ol>

            <p>14.<code>phonopy -p -s band.conf</code></p>

            <p>使用phonopy读取<code>band.conf</code>文件，作图并保存。</p>

            <p>15.<code>phonopy-bandplot --gnuplot > phonon.out</code></p>

            <p>将数据导出方便后续用Origin等软件重新绘图。</p>

            <div class="extend">
            <p>旧版本的phonopy的导出命令为：<code>bandplot  --gnuplot> phonon.out</code></p>
            </div>

            <h3 id="subsec:具体计算步骤-有限位移法计算声子谱">有限位移法计算声子谱</h3>

            <p>1.<code>mkdir method_yxwy</code></p>

            <p>2.<code>cp relax/CONTCAR method_yxwy/POSCAR</code></p>

            <p>3.<code>cd method_yxwy</code></p>

            <p>4.<code>phonopy -d --dim="6 6 1"</code></p>

            <p>前四步和DFPT法完全相同。</p>

            <p>5.<code>for i in {01..12}; do mkdir $i; cp POSCAR-0$i $i/POSCAR;done</code></p>

            <p>假如第四步产生了12个位移文件，使用<code>for</code>循环生成12个文件夹，并将对应的位移<code>POSCAR</code>移入文件夹重命名为<code>POSCAR</code>。</p>

            <p>6.准备其它基本文件：</p>
            <h4>INCAR</h4>
<pre><code>
ADDGRID = .TRUE.
PREC = Accurate
IBRION = -1
ENCUT = 380
EDIFF = 1E-8
EDIFFG = -1E-3

ISMEAR = 0
SIGMA = 0.03

IALGO = 38

LREAL = .FALSE.
LWAVE = .FALSE.
LCHARG = .FALSE.

NCORE = 4
        </code></pre>

            <div class="attention">
            <p>有限位移法的单个计算实际上就是高精度的静态自洽。</p>
            </div>
            <h4>KPOINTS</h4>
            <pre><code>
Automatic mesh
0
Gamma
3 3 1
0 0 0
            </code></pre>

            <div class="attention">
            <p>同DFPT法一样，有限位移法使用的也是扩胞之后的结构，所以K点没有必要取太大。</p>
            </div>

            <p>7.<code>for i in {01..12}; do cp INCAR KPOINTS POTCAR sub.vasp $i; cd $i; sbatch sub.vasp; cd $OLDPWD;done</code></p>

            <p>将基本文件复制进各个小文件夹中并进行计算。</p>

            <p>8.<code>phonopy -f {01..12}/vasprun.xml</code></p>

            <p>计算全部结束后，使用phonopy读取全部的计算文件夹中的<code>vasprun.xml</code>，生成<code>FORCE_SETS</code>文件。</p>

            <p>9.<code>vi band.conf</code></p>
            <h4>band.conf</h4>
            <pre><code>
ATOM_NAME =Ti Te
DIM = 6 6 1
BAND =0 0 0  0.5 0 0  0.33333 0.33333 0   0 0 0
BAND_POINTS = 101
FORCE_SETS = READ
            </code></pre>

            <p>与DFPT方法唯一不同的部分在于将<code>FORCE_CONSTANTS=READ</code>改成<code>FORCE_SETS=READ</code>。</p>

            <p>10.<code>phonopy -p -s band.conf</code></p>

            <p>使用phonopy读取<code>band.conf</code>文件，作图并保存。</p>

            <p>11.<code>phonopy-bandplot --gnuplot > phonon.out</code></p>

            <p>将数据导出方便后续用Origin等软件重新绘图。</p>
        </div>
        <div id="sec:声子谱分析" class="chapter-content" style="display: none;">
            <h2>声子谱分析</h2>
            <p><strong>作者：</strong>Isay K.<p></p>

            <p>我还不太会，等我学学。</p>

            <a href="http://pubs.acs.org/doi/abs/10.1021/acs.jpcc.5b04669">http://pubs.acs.org/doi/abs/10.1021/acs.jpcc.5b04669</a>
        </div>
        <div id="sec:错误处理" class="chapter-content" style="display: none;">
            <h2>错误处理</h2>
            <p><strong>作者：</strong>Isay K.</p>

            <p>vasprun.xml没有必要信息</p>
        </div>

        <div id="sec:能带基础理论" class="chapter-content" style="display: none;">
            <h2>能带理论基础</h2>
            <p><strong>作者：</strong>Jiaqi Z.<p>

            <h3>知识点</h3>
            <ul>
            <li>什么是能带</li>
            <li>能带的三个重要近似</li>
            </ul>

            <p>在本章，我们将要了解材料计算的一个重要内容--关于能带的计算。毫不夸张地说，能带论是目前研究固体中的电子状态，说明固体性质最重要的理论基础。一个最简单的例子是，利用能带的相关计算，我们可以从严格的角度判断材料的导电性。</p>

            <div class="extend">
                <p>导体和绝缘体的概念，贯穿了我们的学习生涯。而这一概念也在随着认知水平的增长发生变化。</p>

                <p>最开始接触的时候，我们认为，导体是那些带有电荷的物质，而绝缘体内部没有电荷。这一结论是我们对“电”和“电荷”的初步认识，显然是不准确的。进一步学习了物理后，我们了解到：任何原子都是由原子核和电子组成的，所谓的导体，就是存在“自由移动的电子”，相反，绝缘体就是没有自由电子的物质。这一概念结合了原子和电子的认识，相比于最开始的“电荷”，显然更准确了。</p>

                <p>到了现在，我们将要了解到能带。基于能带理论，在导体中，价带（价电子所在的能带）和导带（电子可以自由移动的能带）是重叠的，或者价带顶部和导带底部之间的能隙（带隙）非常小，甚至为零。这意味着电子可以轻易地从价带跃迁到导带，从而在电场作用下自由移动，形成电流。而对于半导体而言，价带和导带之间存在一个较大的带隙，电子要跃迁到导带需要吸收足够的能量（如热能或光能）。在常温下，电子通常没有足够的能量来跃迁，因此电子不能自由移动，导致绝缘体不导电。</p>
            </div>

            <h3 id="subsec:能带理论基础-什么是能带">什么是能带</h3>

            <p>从原子物理的知识来看，一个孤立原子的电子只能处在特定的能级当中。而我们所计算的材料，往往是周期性的多原子材料<sup>1</sup>。对于多原子而言，电子和电子之间、电子和原子核之间会产生相互作用，此时电子的能级就会发生“展宽”，从而变成一系列的带状结构。称为“能带”。</p>

            <div class="attention">
                <p>通常情况下，能带仅在周期性材料中讨论。对于单分子（如气体分子等），计算能带往往没有意义。</p>
            </div>

            <h3 id="subsec:能带理论基础-能带理论的三个近似">能带理论的三个近似</h3>

            <p>我们不会在这一教程中详细介绍能带的推导过程，但是我们还是有必要在这里提到三个重要的近似。这些近似可以说是能带理论的基础，甚至可以说是整个第一性原理计算的基础。</p>

            <ul>
                <li>Born-Oppenheimer近似，又名绝热近似：因为原子核比电子重的多，所以原子核比电子具有更大的惯性，更难运动。因此，我们只考虑电子的运动，原子核是被固定住的。</li>
                <li>单电子近似（独立电子近似、平均场近似）：将电子与电子相互作用等效成一个平均值，电子是在一个平均场中运动。</li>
                <li>周期场近似：平均场是周期性的。</li>
            </ul>

            <p>具体内容在任何一本固体物理教材中都会详细提到，这里不再赘述。</p>

            <footer>
                <p>注解：</p>
                <ol>
                <li id="ftnt1">对于VASP而言，所有材料都是“周期性”的。我们所说的单原子或单分子计算，通常是通过调整晶格的大小，从而减弱相互之间的作用，近似成“单分子”计算。</li>
                </ol>
            </footer>
        </div>

        <div id="sec:VASP计算能带过程" class="chapter-content" style="display: none;">
            <h2>VASP计算能带过程</h2>
            <p><strong>作者：</strong>Jiaqi Z.<p>

            <h3>知识点</h3>
            <ul>
            <li>如何使用VASP计算PBE能带</li>
            </ul>

            <p>在本节，我们将详细讨论如何使用VASP计算能带。我们先讨论最简单的PBE能带计算过程，旨在通过这一流程，掌握计算能带的完整步骤。在这一基础上，后面将会详细讨论精度更高的计算方法（如HSE能带计算等）。</p>

            <div class="attention">
                <p>使用PBE计算能带往往会得到较小的带隙，如果你使用数据库或文献中的能带图进行复现，可能会得到与文献不同的带隙。这一点是PBE泛函计算能带所固有的缺陷。</p>
            </div>

            <h3 id="subsec:VASP计算能带过程-结构优化">结构优化</h3>

            <p>在这一部分计算能带时我们使用SiO<sub>2</sub>为例进行分析。所使用数据库来源自<a href="https://legacy.materialsproject.org/materials/mp-546794/">Materials Project</a>。</p>

            SiO<sub>2</sub>的结构文件<code>POSCAR</code>如下所示：

            <pre><code>
Si2 O4
1.0
        5.1358423233         0.0000000000         0.0000000000
        0.1578526541         5.1334159104         0.0000000000
        -2.6468476750        -2.5667081359         3.5753437737
    Si    O
    2    4
Direct
        0.750000000         0.250000000         0.500000000
        0.000000000         0.000000000         0.000000000
        0.787033975         0.625000000         0.662033975
        0.875000000         0.212965995         0.837966025
        0.962966025         0.125000000         0.337965995
        0.375000000         0.037034001         0.162034005
            </code></pre>

            <div class="attention">
                在计算能带时，大多数时候我们只讨论原胞的计算。因此，在使用Materials Project等数据库导出结构时，应当优先导出原胞结构（Primitive Cell）。

                对于无法导出原胞的情况，可以借助于其他程序或脚本文件。以vaspkit为例，借助于<code>vaspkit-602</code>，可以得到<code>PRIMCELL.vasp</code>文件，将其重命名为<code>POSCAR</code>文件即可。
            </div>

            <div class="extend">
                <p>对于一些特殊情形（例如需要掺杂等情况），不得不使用超胞进行计算。如果确实需要计算能带结构，往往需要对能带进行<strong>反折叠</strong>以得到更清楚的图像。我们将在后面的部分对这一技术进行讨论。</p>

                <p>目前，我们所讨论的结构都是原胞。</p>
            </div>

            <p>在计算能带之前，首先需要对材料进行结构优化。为得到结构优化所用<code>INCAR</code>文件，使用<code>vaspkit-101-LR</code>生成。同时调整其中的部分参数，修改后的<code>INCAR</code>文件如下：</p>

            <pre><code>
Global Parameters
ISTART =  1
LREAL  = .FALSE.
ENCUT  =  600
PREC   =  Accurate
LWAVE  = .TRUE.
LCHARG = .TRUE.
ADDGRID= .TRUE.
    
Lattice Relaxation
NSW    =  300
ISMEAR =  0
SIGMA  =  0.05
IBRION =  2
ISIF   =  3
EDIFFG = -1.5E-02
            </code></pre>

            <p>其中，需要特别注意并调整的是：</p>

            <ul>
                <li><code>ENCUT</code>：截断能。通常设置为600或更高，但更高的截断能往往意味着更长的机时。同时，在后续所有计算中，截断能应当保持不变。</li>
                <li><code>ISIF</code>：表示优化方式。对于一般的结构优化，通常设置为<code>ISIF=3</code>表示<strong>优化原子坐标和晶格参数</strong>。对于一些特殊的材料（如二维材料），一些晶格参数可能不希望发生变化，此时可以设置<code>OPTCELL</code>文件，其内容为$3\times3$的矩阵，分别对应<code>POSCAR</code>当中的晶格参数坐标。其元素可以是0（表示不优化该坐标）或1（表示优化该坐标）。对于晶格参数不变的情况，可以设置为<code>ISIF=2</code>表示<strong>只优化原子坐标</strong>。</li>
                <li><code>EDIFFG</code>：表示优化收敛标准。其中正数表示<strong>能量收敛标准</strong>（即能量变化小于这一数值时停止计算），而负数表示<strong>力收敛标准</strong>（原子作用力小于这一数值的绝对值时停止计算）。</li>
                <li><code>NSW</code>：表示<strong>最大离子步</strong>。当优化离子步达到设定数值时停止计算（此时往往未达到收敛标准，需要重新计算）。或者，当<code>EDIFFG=0</code>时，计算达到设定<code>NSW</code>时停止计算。</li>
            </ul>

            <p>对于<code>KPOINTS</code>文件，在结构优化时可以使用“自洽计算”的K点，使用<code>vaspkit-102</code>生成，通常设定Gamma点（2），选择密度时通常设定为0.02-0.04即可。</p>

            <p>本例使用<code>vaspkit-102-2-0.02</code>生成<code>KPOINTS</code>文件如下所示：</p>

            <pre><code>
K-Spacing Value to Generate K-Mesh: 0.020
0
Gamma
12  12  14
0.0  0.0  0.0
            </code></pre>

            <div class="attention">
                使用vaspkit生成K点的同时，脚本会同步生成赝势文件<code>POTCAR</code>。但为了确保生成文件的正确性，建议使用<code>grep TITEL POTCAR</code>查看赝势文件是否正确（与<code>POSCAR</code>文件相比较）<sup>1</sup>。
            </div>

            <p>将以上文件放置在一个目录下，提交任务计算后得到<code>CONTCAR</code>文件，即为优化后得到的结构文件。</p>

            <h3 id="subsec:VASP计算能带过程-自洽计算">自洽计算</h3>

            <p>计算完成后，新建一个目录（例如命名为<code>scf</code>），将结构优化得到的<code>CONTCAR</code>文件复制（或移动）到<code>scf</code>目录内，并重命名为<code>POSCAR</code>。</p>

            <p>将结构优化的<code>KPOINTS</code>和<code>POTCAR</code>复制（或移动）到<code>scf</code>目录内。</p>

            <p>使用<code>vaspkit-101-ST</code>命令生成自洽计算所需要的<code>INCAR</code>文件。其中需要将截断能<code>ENCUT</code>设置为结构优化所使用的标准。修改后得到的<code>INCAR</code>文件如下所示：</p>

            <pre><code>
Global Parameters
ISTART =  1
LREAL  = .FALSE.
ENCUT  =  600
PREC   =  Accurate
LWAVE  = .FALSE.
LCHARG = .TRUE. 
ADDGRID= .TRUE. 

Static Calculation
ISMEAR =  0
SIGMA  =  0.05
LORBIT =  11
NEDOS  =  2001
NELM   =  60
EDIFF  =  1E-08
            </code></pre>

            <p>其中需要特别注意的设置是：</p>

            <ul>
                <li><code>LWAVE</code>：表示写入波函数文件<code>WAVECAR</code>，通常用于继续计算时的初始化设定。由于文件较大，因此如无必要，通常可以将其设定为<code>.FALSE.</code>表示不写入文件。</li>
                <li><code>LCHARG</code>：表示写入电荷密度文件<code>CHGCAR</code>。在计算能带时，由于需要使用到这一文件，因此需要将其设定为<code>.TRUE.</code>。</li>
                <li><code>EDIFF</code>：表示电子收敛标准。当能量变化达到这一标准时结束迭代计算。</li>
            </ul>

            <p>将所有文件准备好后提交任务。</p>

            <h3 id="subsec:VASP计算能带过程-能带计算">能带计算</h3>

            <p>相比于自洽计算，能带计算所需要的K点是特殊的<strong>高对称点路径</strong>，因此关键在于KPOINTS的生成。</p>

            <p>将自洽计算得到的<code>CHGCAR</code>, <code>POSCAR</code>, <code>INCAR</code>, <code>POTCAR</code>全部复制（或移动）到一个新的目录下（假设为<code>band</code>）。</p>

            使用<code>vaspkit-3</code>生成计算能带所用<code>KPOINTS</code>文件。其中需要根据结构特点选择是二维材料还是三维材料，在本例中由于SiO<sub>2</sub>是三维材料，因此使用<code>KPOINTS-303</code>生成<code>KPATH.in</code>文件，将其命名为<code>KPOINTS</code>文件。生成后得到的文件如下所示。

            <pre><code>
K-Path Generated by VASPKIT.
20
Line-Mode
Reciprocal
0.0000000000   0.0000000000   0.0000000000     GAMMA          
0.0000000000   0.0000000000   0.5000000000     X              

0.0000000000   0.0000000000   0.5000000000     X              
0.2500000000   0.2500000000   0.2500000000     P              

0.2500000000   0.2500000000   0.2500000000     P              
0.0000000000   0.5000000000   0.0000000000     N              

0.0000000000   0.5000000000   0.0000000000     N              
0.0000000000   0.0000000000   0.0000000000     GAMMA          

0.0000000000   0.0000000000   0.0000000000     GAMMA          
0.5000000000   0.5000000000  -0.5000000000     M              

0.5000000000   0.5000000000  -0.5000000000     M              
0.3674577537   0.6325422463  -0.3674577537     S              

-0.3674577537   0.3674577537   0.3674577537     S_0            
0.0000000000   0.0000000000   0.0000000000     GAMMA          

0.0000000000   0.0000000000   0.5000000000     X              
-0.2349155075   0.2349155075   0.5000000000     R              

0.5000000000   0.5000000000  -0.2349155075     G              
0.5000000000   0.5000000000  -0.5000000000     M              
            </code></pre>

            <p>其中每相邻两个点都是对应于一条高对称点路径。</p>

            <p>对于<code>INCAR</code>文件，需要在自洽所使用文件的基础上，添加<code>ICHARG=11</code>表示<strong>读取当前目录下的<code>CHGCAR</code>文件</strong>，从而用于非自洽计算。</p>

            <div class="extend">
                在这里我们提到了<strong>自洽计算</strong>和<strong>非自洽计算</strong>，简单来说，自洽计算就是用来计算电子结构最稳定状态，而非自洽计算则是利用这一结构计算电子的其他性质（如能带、态密度等）。
            </div>

            <p>将以上文件整理后提交任务计算。至此我们就已经完成了VASP计算能带的所有过程。</p>


            <footer>
                <p>注解：</p>
                <ol>
                <li id="ftnt1">我也不知道为什么它是“TITEL”而不是“TITLE”，如果实在记不住的话用<code>TIT</code>也能搜索到对应内容。</li>
                </ol>
            </footer>
        </div>

        <div id="sec:能带绘图与后处理" class="chapter-content" style="display: none;">
            <h2>能带绘图与后处理</h2>
            <p><strong>作者：</strong>Jiaqi Z.<p>

            <h3>知识点</h3>
            <ul>
            <li>如何使用Origin绘制能带图</li>
            <li>如何使用vaspkit自动生成能带图</li>
            </ul>

            <p>在上一节的计算中，我们已经得到了能带所需要的全部信息。但是，使用计算软件得到的仅仅是数据，与我们所需要的“<strong>能带图</strong>”还差一个步骤--数据后处理。</p>

            <p>在这一节，我们将讨论如何借助于vaspkit软件绘制能带图。其中，最基本的方法是使用Origin绘图，但在vaspkit的更新过程中，也添加了借助于Python脚本自动绘图的功能。我们将在本节首先介绍如何配置可自动绘图的vaspkit，然后介绍如何使用vaspkit自动绘图。</p>

            <div class="attention">
                vaspkit自动绘图并不一定在所有版本都可用，同时这依赖于服务器的配置是否有必要的包（如Python，matplotlib等）。因此，你不应当将vaspkit自动绘图作为依赖，而是作为一个“备选项”。

                使用Origin绘图应当是绘制能带图首先需要掌握的内容。
            </div>

            <h3 id="subsec:能带绘图与后处理-使用Origin绘制能带图">使用Origin绘制能带图</h3>

            <p>使用Origin绘制能带图的第一步是<strong>得到能带图上每一点的坐标</strong>，借助于vaspkit我们可以很容易实现。利用<code>vaspkit-211</code>可以得到绘制能带图所需要的<code>BAND.dat</code>文件，其中包含了能带图的数据点坐标，下面则是文件开始的一部分：</p>

            <pre><code>
#K-Path(1/A) Energy-Level(eV)
# NKPTS & NBANDS: 180  64
# Band-Index    1
    0.00000    -19.370800
    0.04630    -19.368108
    0.09260    -19.360010
    0.13890    -19.346551
    0.18520    -19.327775
    0.23150    -19.303736
    0.27780    -19.274533
            </code></pre>

            <p>除此之外，我们还会得到<code>KLINES.dat</code>文件，用于生成高对称点坐<code>BAND.dat</code>文件后新添一列，并将<code>KLINES.dat</code>文件复制到新添的列中，得到的文件如图所示。</p>

            <img src="fig/BAND_dat.png" weight="50%">

            <p>将新添加的C列（<code>KLINES.dat</code>文件中的x坐标的属性设置为“X”（方法：右键点击上方列名-“设置为”-X）</p>

            <p>将这4列数据全选后点击菜单栏“绘图”-“基础2D图”-“折线图”即可得到所绘制的能带如图所示。</p>

            <img src="fig/Origin生成能带.png" weight="50%">

            <p>调整线型与坐标范围，并在下方添加高对称点标签（可以借助于vaspkit生成的<code>KLABELS</code>文件，其中包含所有高对称点坐标所对应的x轴坐标）</p>

            <div class="attention">
                <p>一般来说，默认生成的能带图都会如上图所示包含较多的能带。但在实际研究中，我们往往仅关心费米能级附近（即0点附近）的情况。此时除了可以使用Origin调整坐标轴范围的方法，也可以在使用VASP计算自洽和能带的时候使用<code>NBANDS</code>参数，设置<strong>需要显示的能带数量</strong>。</p>

                <code>在使用vaspkit自动生成能带图时，则需要对这一参数进行设置。</code>
            </div>

            <p>处理后得到的能带图如图所示<sup>1</sup></p>

            <img src="fig/SiO2能带图.png" weight="50%">

            <h3 id="subsec:能带绘图与后处理-使用vaspkit自动生成能带图">使用vaspkit自动生成能带图</h3>

            <p>自1.2.5版本之后，vaspkit更新了自动绘图的功能。利用这一功能，可以不将数据下载至本地后使用Origin绘图，而是直接在Linux操作系统中得到能带图像。</p>

            <p>使用vaspkit自动绘图的过程是比较简单的，但我们需要提前对vaspkit做一些配置上的设置。</p>

            <h4>vaspkit配置过程</h4>

            <div class="attention">
                <p>请首先检查你所使用的vaspkit是否为1.2.5或更新版本。你可以直接使用<code>vaspkit</code>命令，在菜单栏上方，可以查看所使用的软件版本。</p>

                <p>同时，你还应当确认你的系统上已经配置了Python相关环境，以及绘图所必须的matplotlib包。通常，使用Anaconda可以“一次性”完成Python所需要的所有配置。确认是否安装Anaconda的一个方法是使用命令<code>conda --version</code>，若输出版本号，则表明已经配置了Anaconda<sup>2</sup>。</p>

                <p>如果存在没有的命令或模块，可能需要重新安装。详细安装过程请查阅对应软件官网<sup>3,4</sup>的说明。</p>
            </div>

            <p>假设你的系统已经确认可以配置，在开始之前还需要做如下操作：</p>

            <ol>
                <li>使用<code>which python3</code>查看<strong>python3所在目录</strong>。你需要记住这一路径，将其首先复制到本地的记事本或其他地方是一个好方法；</li>
                <li>使用<code>which vaspkit</code>查看<strong>vaspkit所在目录</strong>，并使用<code>cd</code>命令进入这一目录（通常只需要进入到版本号所在目录即可，例如，在我所在课题组当中，目录为<code>/opt/pub/softwares/VASPKIT/1.5.1</code>）；</li>
                <li>在这一目录下，找到<code>how_to_set_environment_variables</code>文件，并将其中从<code>#BEGIN_CUSTOMIZE_PLOT</code>到<code>#END_CUSTOMIZE_PLOT</code>之间的所有内容（包括这两行）复制到某个地方，以便稍后使用；</li>
                <li>回到所在家目录，新建一个<code>.vaspkit</code>文件，并在其中创建如下两行：
                <pre><code>
PYTHON_BIN    /opt/pub/toolkits/anaconda3/bin/python3
AUTO_PLOT     .TRUE.
                </code></pre>
                其中，<code>PYTHON_BIN</code>后面对应的是之前所复制的python3所在目录。然后，在文件下方将所复制的<code>#BEGIN_CUSTOMIZE_PLOT</code>到<code>#END_CUSTOMIZE_PLOT</code>之间的所有内容粘贴至后面。</li>
            </ol>

            <h4>使用vaspkit绘图</h4>

            <p>在使用vaspkit绘图前，应当首先保证你已经导入了相应模块（如Anaconda等）。与正常使用vaspkit导出能带图类似，在使用<code>vaspkit-211</code>导出时，会询问导出图片是仅导出能带图，还是能带图加态密度。我们在这里选择仅绘制能带图（1），得到如图所示的图像。</p>

            <img src="fig/vaspkit自动生成能带图.png" weight="50%">

            <div class="extend">
                正如你所见那样，使用vaspkit默认生成的能带图是很大的能量范围，且不能对其进行调整。一个简单的方法是在计算时使用<code>EMIN</code>和<code>EMAX</code>参数设置能量区间。
            </div>

            <h3 id="subsec:能带绘图与后处理-如何计算带隙">如何计算带隙</h3>

            <p>有时，我们可能不是强制要求需要得到能带图，而仅仅关注结构的带隙性质（如带隙大小，类型等）。此时，可以直接使用在绘图过程中生成的<code>BAND_GAP</code>文件（使用<code>vaspkit-211</code>生成）。以SiO<sub>2</sub>为例，文件内容为：</p>

            <pre><code>
Band Character:    Direct
Band Gap (eV):    5.7105
Eigenvalue of VBM (eV):   -0.6699
Eigenvalue of CBM (eV):    5.0407
Fermi Energy (eV):   -0.4270
HOMO & LUMO Bands:        16        17
Location of VBM: -0.000000  0.000000  0.000000
Location of CBM: -0.000000  0.000000  0.000000
            </code></pre>

            <p>其中，<code>Band Character</code>表明带隙类型是直接带隙（Direct）或间接带隙（Inderect）；<code>Band Gap</code>表明所计算结构的带隙大小，在本例中为5.71 eV。除此之外，这一文件还提供了如HOMO（最高占据分子轨道）和LUMO（最低未占据分子轨道）所对应的能带条数，以及VBM（价带顶）和CBM（导带底）所对应的K点坐标。</p>

            <div class="attention">
                <p>如果你关注过最开始Materials Project所记录的数据，可能会发现，数据库内所给的带隙约为5.8 eV。而我们所计算得到的比实际带隙小了约0.1 eV。正如<a src="#sec:VASP计算能带过程">“VASP计算能带过程”</a>一节开始所说的那样，这一误差是由于PBE泛函所导致的，而这是PBE泛函的固有缺陷。在一些需要精确计算的情况下，我们可能希望计算HSE能带而不是PBE能带。</p>
            </div>


            <footer>
                <p>注解：</p>
                <ol>
                <li id="ftnt1">绘图配色可以根据自己喜好选择。</li>
                <li id="ftnt2">在有些服务器上，可能需要其他设置引入Anaconda模块。例如，在我所在课题组的服务器上，使用之前需要调用<code>module load anaconda3</code>导入相关模块。</li>
                <li id="ftnt3"><a href="https://vaspkit.com/">VASPKIT官网</a></li>
                <li id="ftnt4"><a href="https://www.anaconda.com/">Anaconda官网</a></li>
                </ol>
            </footer>
        </div>

        <div id="sec:HSE能带计算" class="chapter-content" style="display: none;">
            <h2>HSE能带计算</h2>
            <p><strong>作者：</strong> Jiaqi Z.</p>

            <h3>知识点</h3>
            <ul>
            <li>如何计算HSE能带</li>
            </ul>

            <p>在之前介绍PBE能带计算时提到，<strong>使用PBE计算会得到带隙偏小的情况</strong>，而这对于高精度计算显然是不合适的。因此，在大多数计算能带的论文中都需要其他泛函如HSE计算得到的能带。因此，在本节我们将讨论如何使用HSE计算能带并给出更加准确的带隙。</p>

            <h3 id="subsec:HSE能带计算-结构优化与自洽计算">结构优化与自洽计算</h3>

            <p>在本节我们将讨论的结构是金刚石，其<code>POSCAR</code>文件如下所示：</p>

            <pre><code>
C2
1.0
        2.5269944668         0.0000000000         0.0000000000
        1.2634972334         2.1884414035         0.0000000000
        1.2634972334         0.7294804678         2.0632823422
    C
    2
Direct
        0.750000000         0.750000000         0.750000000
        0.500000000         0.500000000         0.500000000
            </code></pre>

            <p>对于HSE泛函计算能带，结构优化过程与前面<a href="#subsec:VASP计算能带过程-结构优化">VASP计算能带过程-结构优化</a>所介绍的步骤完全相同，因此这里不再赘述。</p>

            <p>对于自洽计算，<code>KPOINTS</code>则需要使用hse的K点。生成方法可以使用<code>vaspkit-3-302/303</code>生成<code>KPATH.in</code>后使用<code>vaspkit-25-251</code>生成<code>KPOINTS</code>，其中可以根据需要选择Monkhorst-Pack Scheme或Gamma Scheme方法生成K点<sup>1</sup>。然后需要依次输入scf所使用k点密度（通常设定为<code>0.04</code>）以及计算能带所需要的k点密度（通常也设定为<code>0.04</code>）</p>

            <p>同时，在计算scf时还需要将<code>INCAR</code>的<code>LWAVE = .TRUE.</code>以生成波函数文件，以便计算能带时使用。下面是一个参考使用的<code>INCAR</code>文件：</p>

            <pre><code>
Global Parameters
ISTART =  1
ISPIN  =  1
LREAL  = .FALSE.
ENCUT  =  600   
PREC   =  Accurate
LWAVE  = .TRUE.  
LCHARG = .FALSE.  
ADDGRID= .TRUE.

Static Calculation
ISMEAR =  0       
SIGMA  =  0.05    
LORBIT =  11      
NEDOS  =  2001    
NELM   =  60      
EDIFF  =  1E-08       
            </code></pre>

            <h3 id="subsec:HSE能带计算-HSE能带计算">HSE能带计算</h3>

            <p>上一步计算完成后，将<code>KPOINTS</code>, <code>POTCAR</code>, <code>POSCAR</code>和<code>WAVECAR</code>文件拷贝（或移动）至新的目录（暂且命名为<code>hse-band</code>，使用<code>vaspkit-101-STH6</code>生成HSE计算的<code>INCAR</code>文件，调整必要的参数后如下所示：</p>

            <pre><code>
Global Parameters
ISTART =  1
ISPIN  =  1
LREAL  = .FALSE.
ENCUT  =  600
PREC   =  Accurate
LWAVE  = .FALSE.
LCHARG = .FALSE.
ADDGRID= .TRUE.
    
Static Calculation
ISMEAR =  0
SIGMA  =  0.05
LORBIT =  11
NEDOS  =  2001
NELM   =  60
EDIFF  =  1E-08
    
HSE06 Calculation
LHFCALC= .TRUE.
AEXX   =  0.25
HFSCREEN= 0.2
ALGO   =  ALL
TIME   =  0.4
PRECFOCK= N
            </code></pre>

            <p>这里面的关键参数是<code>AEXX</code>，表示杂化泛函所占的比重，通常设定为0.25是比较合适的。但<strong>这一比值会影响到带隙的大小</strong>，因此在必要的时候需要进行调整以适应实验结果。</p>

            <p>将上述文件提交计算，由于HSE能带计算精度较高，因此需要时间较长<sup>2</sup>。</p>

            <h3 id="subsec:HSE能带计算-HSE能带计算后处理">HSE能带计算后处理</h3>

            <p>与<a href="#sec:能带绘图与后处理">能带绘图与后处理</a>一节所介绍的类似，在HSE计算后也需要对数据进行处理，绘图。但在一些细节上有些许不同：</p>

            <ul>
                <li>在绘制能带图之前，需要确保当前目录下有<code>KPATH.in</code>文件（可以直接使用<code>vaspkit-3-302/303</code>的方式生成，也可以直接从之前<code>scf</code>目录下复制过来；</li>
                <li>使用<code>vaspkit-25-252</code>生成能带数据，所得到的<code>BAND.dat</code>和<code>KLINE.dat</code>文件可以将其放入Origin等软件中绘图（方法参考<a href="#sec:能带绘图与后处理">能带绘图与后处理</a>一节，在此略）</li>
            </ul>

            <p>生成能带数据后，可以通过<code>BAND_GAP</code>文件查看计算得到的带隙。在本地测试时，得到结果为5.29 eV，与文献<sup>3</sup>结果5.38 eV接近。</p>

            <p>同时，我们也可以利用<a href="#sec:VASP计算能带过程">VASP计算能带过程</a>所介绍的PBE能带计算方法，对金刚石的PBE带隙进行计算。结果发现其带隙为4.12 eV，显然小于HSE带隙。</p>

            <footer>
                <p>注解：</p>
                <ol>
                <li id="ftnt1">一般来说，使用Monkhorst-Pack生成K点精度较高，但对于六方晶系，则需要选择Gamma方法。</li>
                <li id="ftnt2">在测试计算时，64核计算时间为7.7个小时。</li>
                <li id="ftnt3">Stoliaroff, A. & Latouche, C. Accurate ab initio calculations on various PV-based materials: Which functional to be used? The Journal of Physical Chemistry C 124, 8467–8478 (2020).</li>
                </ol>
            </footer>
        </div>
        <div id="sec:简单for循环" class="chapter-content" style="display: none;">
            <h2>简单for循环</h2>
            <p><strong>作者：</strong> Jiaqi Z.</p>

            <h3>知识点</h3>
            <ul>
            <li>命令行<code>for</code>循环的基本结构</li>
            <li>如何使用<code>for</code>循环批量处理任务</li>
            <li><code>$OLDPWD</code>变量的使用</li>
            </ul>

            <p>在这一章的最后，让我们看一下关于命令行的最后一个话题——<strong>批量处理</strong>。其中，批量处理的一个基本方法是使用<code>for</code>循环语句。</p>

            <div class="attention">
                <p>更复杂的批量处理可能需要配合下一章介绍的bash批处理脚本，那里面会有进一步复杂的如条件判断等。一般来说，更复杂的批量处理会放到脚本中执行。在本节，我们仅仅讨论一些能使用<code>for</code>循环简单处理的任务。</p>
            </div>

            <div class="extend">
                <p>虽然说是“最后一个话题”，但实际上关于命令行的使用远不止此。只不过目前教程（或者说科研过程中）可能涉猎到的也就这些。一些更复杂的，或者更细节的使用，例如系统本身操作等，我们并没有对此进行讲解。对于需要的人来说（例如服务器维护相关人员），请查阅更专业的书籍或相关手册了解更多如系统目录架构，以及服务器维护，root权限等相关内容。<sup>1</sup></p>
                
                <p>对于一些后续可能会用到的命令，会有新的补充，请继续关注仓库内版本更新，或者网页端动态更新。</p>
            </div>

            <h3 id="subsec:简单for循环-for语句基本结构"><code>for</code>语句基本结构</h3>

            <p>在Linux当中，<code>for</code>语句的基本结构为：<code>for [变量名] in [列表范围]; do [要执行的语句]; done</code>。其中，<code>[列表范围]</code>可以使用大括号将其依次列出，例如<code>{a,b,c,d,e}</code>表示<strong>遍历这五个字母</strong>。同时，在<code>do</code>后面需要是按顺序执行的语句，其中每一个语句后面以分号（<code>;</code>）结尾。</p>

            <div class="attention">
                <p>在Linux当中，分号表示一个命令的结束，对于最后一个语句可以不加分号（此时回车表示结束）。例如，希望一次性输出<code>POSCAR</code>和<code>CONTCAR</code>文件的最后几行，可以一次性运行两句命令<code>tail POSCAR; tail CONTCAR</code>，其中分号表示这是两个语句。</p>

                <p>在<code>for</code>循环中，你也可以这样理解分号，其中<code>done</code>前面只需要有一个分号（表示语句与<code>done</code>的分割）。换言之，<strong>不可能有两个分号相邻</strong>。</p>
            </div>

            <h3 id="subsec:简单for循环-关于变量">关于变量</h3>

            <p>如果只是重复执行几个没有丝毫变化的语句，似乎有点“无趣”。但我们如何在命令中加入一些可以变化的东西呢？那就是<strong>变量</strong>。在Linux命令行当中，变量是以<code>$</code>符号表示的。例如，<code>$i</code>表示变量<code>i</code>。因此，如果我们希望一次性创建a到e五个目录，则可以使用下面的语句：<code>for i in {a,b,c,d,e}; do mkdir $i; done</code>。其中，<code>for i in {a,b,c,d,e}</code>表示<strong>遍历后面的列表，并分别将变量<code>i</code>赋值为列表中的元素</strong>；后面的语句表示执行<code>mkdir</code>命令，但其中的参数为变量<code>i</code>，例如，第一次时执行的为<code>mkdir a</code>，第二次就为<code>mkdir b</code>，以此类推。</p>

            <div class="extend">
                <p>在所有变量中，有一些变量是比较特殊的，它们具有特定的含义。比较常见的如<code>$PWD</code>表示<strong>当前所在的目录路径</strong>；<code>$OLDPWD</code>表示上一个所在的目录路径。</p>

                <p>在一般的命令行中，你也可以在必要的时候使用这些命令（哪怕不是在循环中）。例如，<code>echo $PWD</code>表示打印当前路径<sup>2</sup>。（事实上，你也可以直接使用<code>pwd</code>命令快速实现这一功能）</p>

                <p>特别注意的是，<code>$OLDPWD</code>表示上一个所在的目录路径，而不是上一级目录。例如，原先在<code>1/a/</code>目录下，当你使用<code>cd 1/b/</code>切换到<code>1/b/</code>目录时，变量<code>$OLDPWD</code>表示的是<code>1/a/</code>而不是它的上一级目录<code>1/</code>。使用<code>cd $OLDPWD</code>可以帮助你快速切换到上一个操作的目录，但还有一个更简单的方法是使用<code>cd -</code>，这二者是等价的。</p>
            </div>

            <div class="attention">
                <p>就目前在写作的过程中，我还没有具体了解到如何在<code>for</code>循环中使用两个变量。类似于<code>for i,j in {a,b,c},{1,2,3}</code>这种写法是<strong>不可行的</strong>。如果你了解到了具体实现这一效果的方法（在命令行下），请通过前面的联系方式联系我。</p>
            </div>

            <h3 id="subsec:简单for循环-seq序列"><code>seq</code>序列</h3>

            <p>在前面使用<code>for</code>循环时，我们需要把遍历元素全部列举出来。通常这种方法适合于一些没有特定模式的序列，且数量较少。对于数量较多，或者我们明确知道其规律（通常是一些数字序列），一般会选择使用序列的方式让命令行自动生成。在Linux当中，最普遍的<strong>数字序列</strong>生成的方法是使用<code>seq</code>命令，其形式为<code>seq &lt;起始数值&gt; &lt;步长&gt; 终止数值</code>。当只有一个参数时，起始数值和步长默认为1；两个参数则分别表示起始数值和终止数值（此时步长默认为1）。</p>

            <p>当希望在<code>for</code>循环中使用序列时，需要将<code>seq</code>命令（包括后面的参数）使用反引号（<code>`</code>）括起来。例如，<code>for i in `seq 1 2 10`</code>表示对序列<code>{1,3,5,7,9}</code>进行遍历。</p>

            <div class="attention">
                <p>正如你所见，<code>seq 1 2 10</code>表示序列<code>{1,3,5,7,9}</code>而不包括11，这是因为11超过了终止数值10.而对于<code>seq 1 2 11</code>则包括11.这一点可能与其他编程语言如Python不同，在Python当中，<code>range(1,11,2)</code>不包括最后的11.</p>

                <p><code>seq</code>命令可以使用负步长表示递减序列。例如，<code>seq 5 -1 1</code>表示序列<code>{5,4,3,2,1}</code>。</p>

                <p>同时，<code>seq</code>也可以使用浮点数，例如，<code>seq 0.1 0.1 0.5</code>表示序列0.1到0.5，间隔0.1.</p>
            </div>

            <p>除此之外，对于一些整数的序列，也可以使用更简单的方式，其形式为<code>{起始数值..终止数值..&lt;步长&gt;}</code>。例如，<code>for i in {1..10}</code>表示对1到10进行遍历；而<code>for i in {1..5..2}</code>则对<code>{1,3,5}</code>遍历。</p>

            <p>与<code>seq</code>不同的是，使用<code>..</code>的表示方法还可以对字母序列进行表示，例如，<code>{a..z}</code>表示所有小写字母，同理<code>{A..Z}</code>表示所有大写字母。</p>

            <div class="attention">
                <p>同样的，你也可以使用<code>A..z</code>对大写字母和小写字母进行表示，但此时<strong>还包括一些特殊字符如[,]等</strong>，它们是在ASCII码介于字母中间的部分（91到96）。</p>

                <p>特别注意的一点是，使用<code>..</code>的方法不能对浮点数进行操作。当然，对于负步长仍然可用，例如，<code>5..1..-1</code>表示序列<code>{5,4,3,2,1}</code>。但对于这一方法，更特别的是你可以省略后面的步长（加上也不错），Linux会自动做降序。更甚者，你可以使用<code>{10..2..2}</code>的方法来生成<code>{10,8,6,4,2}</code>这一序列（此时步长完全是错误的）。</p>
            </div>

            <p>最后再来总结一下，对于整数序列，无论使用哪种方式都能得到；而对于小数（浮点数）序列，只能使用<code>seq</code>方法；对于字母序列则只能使用<code>..</code>方法生成。</p>


            <h3 id="subsec:简单for循环-一些for循环使用例">一些<code>for</code>循环使用例</h3>

            <p>下面，讨论一些<code>for</code>循环的使用方式，仅供启发用（实际使用时可能需要根据实际情况进行个性化调整）。</p>

            <p>首先，如果我们希望生成序列为{200,400,600,800}的目录，则可以使用命令<code>for i in {200..800..200}; do mkdir $i; done</code>。正如你所见的那样，这一命令表示对于这样一个序列进行遍历，执行<code>mkdir</code>命令，其中参数为变量<code>i</code>，依次为200,400,600,800（前面的序列）。</p>

            <p>下面，假设我们在当前目录下有一个文件<code>INCAR</code>，希望将其拷贝至这里面每一个目录下，可以使用命令<code>for i in {200..800..200}; do cp INCAR $i; done</code>。其中表示对序列的每一个变量<code>i</code>，执行<code>cp</code>命令，其中参数（拷贝目标路径）分别设置为序列里的元素。</p>

            <p>最后，当我们希望将每个目录里面的<code>INCAR</code>里面的<code>ENCUT = 200</code>分别改为<code>ENCUT = [目录名]</code>，可以使用下面的方法：<code>for i in `seq 200 200 800`; do cd $i; sed -i "s/200/$i/g" INCAR; cd $OLDPWD; done</code>。这表示对前面的序列\footnote{这里我们使用<code>seq</code>方式生成，仅是为了多一种展示，也可以使用<code>200..800..200</code>，它们是一样的。}，依次执行下面的操作：</p>

            <ol>
                <li>进入其目录；</li>
                <li>使用<code>sed</code>命令修改（使用方法详见<a href="#sec:sed文本替换">sed文本替换</a>一节），其目标文本为变量<code>$i</code>，也就是目录名；</li>
                <li>返回到之前的目录（以便于能够继续遍历其他元素，进入对应目录）</li>
            </ol>

            <div class="extend">
                <p>你可以试一试，如果没有后面的<code>cd $OLDPWD</code>，会发生什么？稍加分析可以看出，当进入<code>200</code>目录时，修改完毕之后，会进入下一次循环遍历，此时尝试执行<code>cd 400</code>。但当前目录下并没有该目录（200和400是并列关系，不是父子目录关系），因此程序会报错。具体的报错可以看下面的<a href="#subsec:简单for循环-错误处理">简单for循环-错误处理</a>一部分。</p>
            </div>


            <h3 id="subsec:简单for循环-错误处理">错误处理</h3>

            <h4>-bash: cd: &lt;目录名&gt;: No such file or directory</h4>

            <p>这就是前面所说的忘记<code>cd $OLDPWD</code>的错误信息，此时会发现，没有目录，怎么办？只能报错了（如果你足够“机敏”，也许你会联想到<a href="#sec:目录操作">目录操作</a>一节。没错，在那里的<a href="#subsec:目录操作-错误处理">目录操作-错误处理</a>当中，也有这一错误。实际上，二者的本质是相同的。</p>

            <h4>seq: invalid floating point argument: &lt;字符&gt;</h4>

            <p>这是因为你在使用<code>seq</code>时尝试生成非数值（整数或浮点数）序列。例如，你也许本意是生成字母a到z的序列，但使用<code>seq a z</code>则会产生上面的错误。正确方法是使用<code>{a..z}</code></p>

            <h4>使用<code>..</code>的方法生成浮点数，结果错误</h4>

            <p>使用<code>..</code>不能生成浮点数。因此，如果你希望生成浮点数，一种方法是使用<code>seq</code>，当然，还有一种“投机取巧”的方法，即尝试将<strong>浮点数用整数表示</strong>。例如，如果希望生成<code>{0.1,0.2,0.3,0.4,0.5}</code>的目录，除了使用<code>for i in `seq 0.1 0.1 0.5`; do mkdir $i; done</code>外，还可以使用<code>for i in {1..5}; do mkdir 0.$i; done</code>。其中<code>0.$i</code>的<code>$i</code>需要替换为遍历的序列（整数），也就是<code>{0.1,0.2,0.3,0.4,0.5}</code>。</p>

            <footer>
                <p>注解：</p>
                <ol>
                <li id="ftnt1">我们不讲解还有一个原因：担心一般使用时出现错误导致服务器崩溃等异常情况出现。</li>
                <li id="ftnt2"><code>echo</code>表示输出显示某一个内容，其后面的参数表示输出的内容。</li>
                </ol>
            </footer>
        </div>

        <div id="sec:第一个脚本" class="chapter-content" style="display: none;">
            <h2>第一个脚本</h2>
            <p><strong>作者：</strong> Jiaqi Z.</p>

            <h3>知识点</h3>
            <ul>
            <li>什么是Shell脚本</li>
            <li>如何编写第一个Shell脚本——Hello World</li>
            <li>如何运行脚本</li>
            </ul>

            <p>在前面的学习中，我们已经了解如何使用Linux命令在Shell进行操作，我们了解了如何对文件和目录进行简单的操作（如删除、复制等），同时我们也了解了一些更复杂的操作，例如使用<code>grep</code>和<code>sed</code>进行文本的查找和替换等。最后，我们还了解了如何使用<code>for</code>循环来进行批量操作。</p>

            <p>而在一些特殊的场景下，我们可能希望做更复杂的操作，或者说，我们希望更简单地执行一些操作（这两句话本质上是一样的）。例如，如果我们每次都需要使用<code>sed</code>命令修改特定的内容，如<code>ENCUT = 400</code>，刚开始还好，时间长了可能就会“嫌麻烦”。此时可能就会希望有一个单独的命令（比如叫做<code>changeENCUT</code>）来实现这一功能。而实现这一功能的方法，就是使用<strong>脚本</strong>。</p>

            <p>在本章，我们将会讨论如何编写自己的脚本。类似于编程语言，脚本里面将会包含大量的编程思想——如输入、输出、条件、判断、函数等。在学习这一部分之前，希望你已经有了部分编程语言基础（没有也没有关系）。</p>

            <div class="extend">
                <p>关于Shell和Bash的区别：一般来说，Shell指的是系统和用户交互的那层“外壳”，之前我们所学习的内容，其操作都是在Shell当中进行的。Shell具有多种版本，如“Bourne Shell”、“Bourne Again Shell”、“C Shell”等。其中，“Bourne Again Shell”就是我们所谓的“bash”。在你的操作系统下，可以使用<code>top</code>命令查看其Shell类型。</p>
                
                <p>Shell脚本，全称叫做“Shell Script”，是一种在Shell当中批量运行多条语句的程序。</p>
                
                <p>由于目前主流的Shell是基于Bash解释的，而我们所写的Shell脚本，实际上也大多都是Bash脚本，因此在后文当中，我们可能不会精确区分Bash脚本和Shell脚本的区别。</p>
            </div>

            <h3 id="subsec:第一个脚本-编写第一个脚本">编写第一个脚本</h3>

            <p>正如任何程序的开始都是“Hello World”，在本章我们也不例外。在Linux当中编写Shell脚本不需要额外的程序，只需要使用<code>vi</code>编写一段文本文件，并<strong>赋予它运行权限</strong>，就可以作为脚本运行了。首先通过<code>vi</code>创建一个名为<code>hello</code>的文件，并输入如下内容：</p>

            <pre><code class="bash">
#!/bin/bash
# 输出Hello World!
echo "Hello World!"
            </code></pre>

            <p>编写完成后保存，并添加运行权限（<code>chmod +x hello</code>，详见第<a href="#sec:文件权限管理">文件权限管理</a>一节），然后执行<code>./hello</code>，即可在屏幕上看到输出结果。</p>

            <div class="attention">
                <p>在运行时需要加上<code>./</code>表示在当前目录寻找命令。在Linux当中，不添加<code>./</code>表示在环境变量<code>PATH</code>下查找文件运行，你可以在家目录下找到<code>.bashrc</code>的文件，里面包含有一系列配置Bash的命令，其中就有对环境变量的设置。</p>

                <p>在运行前，你需要保证程序已经具有运行权限，或者可以使用<code>source ./hello</code>或<code>. ./hello</code>的方式（二者等价）“临时赋予运行权限”<sup>1</sup>。</p>
            </div>

            <p>其中，代码第一行<code>#!/bin/bash</code>表示<strong>使用bash运行</strong>。正如前面所说的那样，Shell具有多种版本，因此，在编写时应当特别指定你所使用的版本。由于目前大多数Shell都是使用Bash，因此这一行在有些时候“可以省略”。但我们不建议将其省略，因为<strong>你永远不能保证你的这个脚本今后会在哪个版本的Shell下运行</strong>。</p>

            <div class="extend">
                <p>你可以想见，<code>/bin/bash</code>就是<code>bash</code>命令所在位置，你可以去看一下是不是真的存在。在查看的时候，注意是从“根目录”开始而不是“家目录”</p>

                <p>如果你真的这么做了，一种简单的方法是在<code>/bin/</code>目录下使用<code>ls | grep bash</code>只输出具有“bash”的文件，从而简化输出结果。当然，你也可以直接使用<code>ls bash</code>查看。</p>

                <p>当然，不建议你尝试使用<code>vi bash</code>查看里面的内容，<strong>它不是文本文件</strong>。</p>
            </div>

            <p>代码第二行以<code>#</code>开头表示<strong>注释</strong>。如同编写其他代码一样，使用注释是一个好习惯，它可以帮助你划分代码段落，以及记住对应的功能。随着学习的深入，我们会编写越来越长的脚本。因此，记得加注释是个好习惯。</p>

            <p>第三行是这一脚本的关键，它使用<code>echo</code>实现字符串的输出。事实上，Shell脚本的每一个命令都可以在Shell本身下运行。因此，你也可以直接在Shell运行这一命令，会实现同样的效果。而编写脚本之后，就可以直接通过<code>./hello</code>实现这一功能，这便是脚本的作用。</p>

            <div class="attention">
                <p><code>echo</code>会将它后面的所有内容输出（在其他一些编程教材中，会将这一功能叫做“应声虫”，实际上，echo也就是“回音”的意思）。我们在这里添加双引号是为了强调它们是整体的，事实上，当你去掉这两个双引号，对程序运行结果没有任何影响。</p>

                <p>如果你在你的脚本中编写了代码，并同样使用了双引号，请注意：<strong>使用英文符号而不是中文符号</strong>，这一点在后续所有脚本编写过程中都应当注意。一般来说，我们不建议在脚本当中添加中文，虽然你写<code>echo "你好，世界！"</code>可能也会得到正确的结果，但不会永远如此。</p>

                <p>在本章的教程中，为了考虑到读者水平，我们的注释部分都会采用中文，如果这样也会引起脚本运行的失败（在测试时正常，但不敢保证在你的电脑也会正常），请删除中文注释后运行。</p>
            </div>

            <h3 id="subsec:第一个脚本-添加至环境变量">添加至环境变量</h3>

            <p>正如前面所说，使用<code>./hello</code>表示在当前目录下查找名为<code>hello</code>的脚本并运行。这可以帮助我们快速调试代码，但在真正应用时，我们可能会希望在任何目录下运行脚本。此时就会希望将代码添加至环境变量，也就是前面所说的<code>PATH</code>。添加方法有两种——将脚本放置到已有的环境变量中，或者将脚本所在的目录设置为环境变量。</p>

            <p>你可以通过<code>$PATH</code>命令输出当前环境变量，通常来说，你可以将你所编写的脚本命令放置在<code>\texttilde/bin/</code>目录下（这一般都是用户的环境变量）完成后，你可以在任何目录下运行你的脚本了（不需要<code>./</code>了）。例如，在完成上述配置后，在任何目录下运行只需要使用<code>hello</code>即可。</p>

            <p>如果你编写了一系列脚本，一个简单的方法是直接将它们所在的目录设置成“环境变量”。此时需要通过<code>.bashrc</code>文件。假设你的脚本所在目录为<code>\texttilde/bash/</code>，使用<code>vi</code>打开<code>.bashrc</code>文件，在最后一行添加<code>export PATH=$HOME/bash:$PATH</code>即可。</p>

            <p>其中，<code>export</code>是用来设置“环境变量”的命令，后面的<code>PATH=...</code>则是“变量赋值”的过程（后面就会学到）。<code>$HOME</code>是系统内置的变量，表示<strong>用户的家目录</strong>，你可以在Shell下使用<code>echo $HOME</code>查看变量的值\footnote{在这里我们又不知不觉接触到<code>echo</code>的新用法：输出变量的值。这本是后面的内容，在这里你可以提前先了解一下。}，后面的<code>$PATH</code>则表示原先的环境变量。</p>

            <p>简单说，这一语句的意思就是在原有的<code>PATH</code>变量前面添加一个新的<code>$HOME/bash</code>。添加完成后你需要使用<code>source \texttilde/.bashrc</code>命令“激活”这一环境变量（或者重启也可以实现这一功能），然后即可在任何地方如一般运行命令一样运行你在<code>\texttilde/bash/</code>目录下所有的脚本了。</p>

            <div class="attention">
                <p>在后面的教学演示中，我们都不会添加<code>./</code>运行脚本（或者说，只有在这一节我们会详细提到如何运行脚本，后面都简单说作“运行脚本”）。如无特殊说明，无论是哪种方法（在当前目录、添加环境变量），运行最终效果都是一样的，后面不再赘述。</p>

                <p>为了你的方便，建议新建一个目录作为你后续练习脚本的目录，并使用上面的方法将其添加到环境变量中。</p>
            </div>


            <h3 id="subsec:第一个脚本-错误处理">错误处理</h3>

            <h4>-bash: &lt;脚本名&gt;: Permission denied</h4>

            <p>这可能是因为你在运行脚本时没有赋予其运行权限而直接运行脚本，如果你没有赋予权限，请使用<code>source</code>命令或<code>.</code>运行脚本。这同样适用于环境变量中的命令。对于环境变量中没有运行权限的脚本，需要使用<code>source &lt;脚本名&gt;</code>或<code>. &lt;脚本名&gt;</code>执行。</p>

            <footer>
            <p>注解：</p>
            <ol>
            <li id="ftnt1">这是表面上的用法，事实上，<code>source</code>本意是<strong>在当前Shell下运行文件</strong>。相对的，其他的用法（不加<code>source</code>）则是在当前shell下新建了一个“子Shell”运行代码，其运行结果（例如一些变量）并不会带回外面。</li>
            </ol>
            </footer>
        
        </div>

        <div id="sec:变量" class="chapter-content" style="display: none;">
            <h2>变量</h2>
            <p><strong>作者：</strong> Jiaqi Z.</p>

            <h3>知识点</h3>
            <ul>
            <li>如何在脚本中定义变量</li>
            <li>如何输出变量</li>
            <li>如何对变量进行简单运算</li>
            </ul>

            <p>如果所有脚本都只能按照固定的内容运行，显然功能太弱了。与其他编程语言类似，脚本语言应当也具有类似于“<strong>变量</strong>”的功能实现“可拓展性”。</p>

            <p>所谓“变量”，指的就是<strong>在运行过程中会发生变化的量</strong>，这些值可能是由用户输入给定的，或者在运行过程中生成的，或者是通过文件读取得到的。</p>

            <h3 id="subsec:变量-定义变量与初始化">定义变量与初始化</h3>

            <p>与C语言等强类型语言不同，Shell脚本的变量在使用之前不需要对其进行“声明”，相对地则是需要对其进行<strong>初始化</strong>。与其他编程语言类似，在Shell脚本中，第一次使用变量时需要对变量进行赋值（也可以叫做“初始化”）。例如，我们希望将字符串“Hello World!”赋值给一个变量，则可以使用<code>STRING="Hello World!"</code></p>

            <div class="attention">
                <p>与其他编程语言类似，在Shell脚本中，赋值也是使用<code>=</code>运算符。但不同的一点是，在运算符两侧<strong>不能有空格</strong>。</p>

                <p>在变量命名时，需要遵守如下原则：变量名只能包括数字、字母和下划线(<code>_</code>)，第一个字符不能是数字，不能是已有的关键字<sup>1</sup>。</p>
            </div>

            <p>在一个程序中，可以同时存在多个变量，对于已经赋值的变量，也可以对其再次进行赋值（原有值会发生变化）。例如，下面的代码：</p>

            <pre><code>
#! /bin/bash
# 变量初始化
STRING1="Hello World!"
STRING2="I Like Bash"
STRING2="I Like Shell Script"
            </code></pre>

            <p>上述代码第3行定义了一个变量<code>STRING1</code>，其赋值为<code>"Hello World!"</code>；在第4行，首先定义了一个变量叫做<code>STRING2</code>，首先赋值为<code>"I Like Bash"</code>，在第5行又一次对其进行赋值，此时<code>STRING2</code>的值变为<code>"I Like Shell Script"</code>。</p>

            <h3 id="subsec:变量-调用变量">调用变量</h3>

            <p>如果你熟悉其他编程语言如C、Java、Python等，也许在编写上面的语句时，你会很自然写出如<code>STRING2=STRING1</code>这样的语句。在你看来，这好像是把<code>STRING1</code>的值赋值给<code>STRING2</code>，但当你运行时，发现事实并非如此。这是因为在Shell脚本中，变量的调用需要用到其他的方法。</p>

            <div class="attention">
                <p>在上面我们提到<code>STRING2=STRING1</code>的含义是<strong>将<code>STRING1</code>的值赋值给<code>STRING2</code></strong>，这对于了解过其他编程语言的读者而言是很自然的。但如果你没有学习过其他编程语言，需要特别注意的一点是：在程序设计语言中（几乎大多数的程序语言），<code>=</code>所表示的含义与你所熟悉的数学上的含义不同。在数学上，=表示一种<strong>状态</strong>，表达两个值相等；而在程序设计中，<code>=</code>表示将右边的值<strong>赋值给</strong>左边的值（一种<strong>动作</strong>）。</p>

                <p>尽管在最后的结果上，二者是相同的，但数学上的=表达一种“状态”，而程序设计中表达一种“动作”，是不同的。一个很简单的例子就是上面的<code>STRING2=STRING1</code>，从数学的角度看，这显然不成立，因为<code>"I Like Shell Script"</code>显然不可能<strong>等于</strong><code>"Hello World!"</code>，但程序设计上是可行的，因为它表达了“赋值”的动作。</p>

                <p>也正因如此，在数学上，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi></math>和<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>b</mi></math>相等写成<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mo>=</mo><mi>b</mi></math>或者<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>b</mi><mo>=</mo><mi>a</mi></math>都是可行的（这也就是等式的“对称性”）；而对于程序设计而言，<code>a=b</code>和<code>b=a</code>显然是不同的，因为它们所表达的动作“方向”是不同的。</p>
            </div>

            <p>在Shell脚本中，调用变量需要使用到<code>$</code>符号。事实上，这不是你第一次见到它（如果你忘记了，请回到<a href="#sec:简单for循环">简单for循环</a>一节，或者更准确的，<a href="#subsec:简单for循环-关于变量">简单for循环-关于变量</a>一节）。与定义变量不同，在Shell脚本中，但凡是需要<strong>调用变量</strong>的地方，都需要使用<code>$</code>符号。例如，在上面的例子中，如果你确实希望表达<code>STRING2=STRING1</code>，需要写作<code>STRING2=$STRING1</code>。</p>

            <p>这里有一点“小绕”的地方在于，为什么在<code>STRING2</code>前面不需要添加<code>$</code>符号。这是因为，我们实际上只是调用了<code>STRING1</code>变量的值，并不关心<code>STRING2</code>里面是<code>"I Like Shell Script"</code>还是<code>"I Like Roselia"</code>。因此，我们只需要通过<code>$STRING1</code>来获得<code>STRING1</code>的值。</p>

            <div class="extend">
                <p>你还可以做一个“不准确”的理解：<code>$</code>总是试图将右边的内容“展开”为完整的内容。例如，假设<code>STRING2</code>的值为<code>"Hello World!"</code>，那么在调用<code>STRING2=$STRING1</code>时，可以写作<code>STRING2="Hello World!"</code>（将变量<code>STRING1</code>展开）</p>

                <p>对于前面所介绍的<code>for</code>循环，其本质是类似的。例如，<code>for i in {1..5}; do echo $i; done</code>，实际上也是将变量<code>i</code>展开为具体的1到5.</p>

                <p>当你了解这个时，对于后面的一些操作，会很有帮助。</p>
            </div>

            <p>在了解了如何调用变量后，我们就可以做一些完整的事情了。例如，下面的一段完整代码实现了变量的初始化，修改赋值和调用，并在最后使用<code>echo</code>语句进行输出。</p>

            <pre><code>
#! /bin/bash
# 变量初始化
STRING1="Hello World!"
STRING2="I Like Bash"
# 修改变量的值
STRING2="I Like Shell Script"
# echo输出变量的值（调用变量）
echo $STRING1
echo $STRING2
            </code></pre>

            <p>运行上述代码，就可以看到输出了“Hello World!”和“I Like Shell Script”。</p>

            <h3 id="subsec:变量-字符串中的$符号">字符串中的$符号</h3>

            <p>像上面这样在字符串中使用<code>$</code>符号，最简单的情况就是上面这种单纯输出一个变量。但大多数时候，我们可能希望在输出时提供更复杂的内容。例如，我们有下面的变量</p>

            <pre><code>
#!/bin/bash
# 初始化变量
name="Jiaqi Z."
band="Roselia"
            </code></pre>

            <p>如果我希望输出“My name is Jiaqi Z., and I like Roselia”。如果考虑到<code>echo</code>可以<strong>连续输出多个参数</strong>，也许你会想写出<code>echo "My name is" $name", and I like" $band</code>这样的语句。确实，从运行的角度，这个句子没有任何问题。但显然从可读性的角度，稍显复杂。那么，有没有更简单，更清晰的方式呢？</p>

            <p>在使用<code>$</code>表示变量时，我们可以将变量名使用大括号将其括起来。例如，上面的例子，我们就可以写作<code>echo "My name is ${name}, and I like ${band}"</code></p>

            <div class="extend">
                <p>如果你尝试将大括号去掉，在这一例子中，同样可以运行出正确的结果。这是因为，<strong>每一个变量名后面都跟着一个“标点符号”</strong>。如果对于再一般的情况，我们的变量名后面跟着另外一些字母。例如，如果我们在<code>$name</code>后面再加个s，对于使用大括号的情况，则会输出<code>Jiaqi Z.s</code>，而对于没有大括号的情况，则会输出错误的结果（由于没有变量叫做<code>names</code>）。</p>

                <p>因此，为了更一般的情况，我们建议<strong>在使用变量名调用变量时加上大括号</strong>。</p>
            </div>

            <h3 id="subsec:变量-变量简单运算">变量简单运算</h3>

            <p>在前面的例子中，我们都是针对于字符串变量进行讨论。事实上，变量还可以保存一些数值信息（例如整数、小数等）。例如，我们可以定义变量<code>a=3</code>和<code>b=2.5</code>。</p>

            <p>同时，在脚本中，我们也可以进行简单的四则运算。简单的方式则是利用<code>$ (( 表达式 ))</code>的格式写出运算内容。例如，下面的代码则是简单计算1+1的结果：</p>

            <pre><code>
#! /bin/bash
# 定义变量
a=1
b=1
# 计算
c=$(( ${a} + ${b} ))
# 输出
echo ${c}
            </code></pre>

            <p>在Shell脚本中，四则运算（加减乘除）的符号分别为<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>，同时需要特别注意的两个符号是<code>%</code>表示<strong>取余</strong>，即<strong>求得两个整数相除后的余数</strong>，例如，计算<code>echo $(( 9%4 ))</code>可以得到1；<code>**</code>（两个乘号）表示<strong>幂运算</strong>，例如，<code>echo $(( 2**10 ))</code>表示<math xmlns="http://www.w3.org/1998/Math/MathML" ><msup><mn>2</mn><mrow><mn>10</mn></mrow></msup></math>，即1024.</p>

            <div class="extend">
                <p>在Shell脚本中，你可以使用这种方法进行整数的四则运算。对于小数而言，则需要使用更复杂的方法。例如，对于变量<code>a=1.5</code>和<code>b=2</code>，如果希望做小数的四则运算，可以使用<code>bc</code>命令，写作<code>echo "${a} + ${b}" | bc</code>。</p>

                <p>但对于脚本来说，通常你不应寄希望于它的运算功能（这主要由于运算效率的限制）。通常来说，对于需要使用复杂运算的任务，应当考虑其他效率更高的编程语言如C语言<sup>2</sup>和Python语言。</p>

                <p>例如，上述问题如果希望使用C语言编写，则可以写作下面的代码：</p>

                <pre><code>
#include "stdio.h"
int main()
{
    double a = 1.5;
    int b = 2;
    printf("%f\n",a+b);
    return 0;
}   
            </code></pre>
                <p>并通过<code>gcc calculate.c</code>的方式编译代码，得到<code>a.out</code>可执行文件。通过<code>./a.out</code>即可运行得到正确结果。</p>

                <p>正因如此，在本教程中，我们不会详细讨论脚本的计算（如果你确实需要使用脚本进行复杂运算，请查阅其他相关资料（例如<code>bc</code>和<code>awk</code>的相关使用方法）</p>
            </div>

            <h3 id="subsec:变量-错误处理">错误处理</h3>

            <h4>-bash: &lt;表达式&gt; : syntax error: invalid arithmetic operator (error token is "&lt;表达式&gt;")</h4>

            <p>这可能是由于你错误使用了四则运算符，例如，在使用<code>$(())</code>的方式进行计算时，要求只能进行整数四则运算。如果你的运算符两边出现了小数，则会出现错误。</p>

            <h4>bash: &lt;变量名&gt;: command not found...</h4>

            <p>这是因为你在对变量进行赋值时，在<code>=</code>两边加了空格。在Shell脚本中，赋值符号(<code>=</code>)两边不能有空格，这一点与其他编程语言不同。</p>

            <footer>
                <p>注解：</p>
                <ol>
                <li id="ftnt1">“关键字”指的是在Shell脚本中已经具有特定含义的词语，如<code>echo</code>就不能作为变量名。</li>
                <li id="ftnt2">在大多数Linux当中都有C语言的编译器<code>gcc</code>，你可以使用<code>gcc --version</code>查看对应版本。</li>
                </ol>
            </footer>
        </div>

        <div id="sec:输入" class="chapter-content" style="display: none;">
            <h2>输入</h2>
            <p><strong>作者：</strong> Jiaqi Z.</p>

            <h3>知识点</h3>
            <ul>
            <li>如何读取用户输入</li>
            <li>如何读取命令参数</li>
            <li>如何将命令执行结果赋值给变量</li>
            </ul>

            <p>在前面，我们仅仅讨论了脚本内定义的变量，这对于脚本而言远远不够。在实际使用脚本的时候，有一些信息只有在调用时才能知道。例如，如果我们希望编写一个可以删除文件的脚本<sup>1</sup>，在编写时不可能知道需要删除哪些文件。因此，有必要在写脚本时考虑实现“交互”。</p>

            <p>通常来说，交互的方式有三种：程序运行时输入、程序调用参数、以及外部文件。在本节，我们将讨论这三种交互方式如何在脚本中实现。</p>

            <div class="attention">
                <p>严格来说，还有一种：管道输入。在本节我们不详细讨论管道的输入方式。</p>
            </div>

            <h3 id="subsec:输入-用户输入">用户输入</h3>

            <p>在Shell脚本中，实现用户输入的方法是使用<code>read</code>语句。一般格式是<code>read &lt;变量名&gt;</code>，例如，<code>read a</code>表示在运行时读取用户输入，并将输入结果赋值给变量<code>a</code>。</p>

            <p>在调用<code>read</code>命令时，可以提供一个选项，<code>-p</code>表示在屏幕上显示提示信息，其格式为<code>read -p &lt;提示信息&gt; &lt;变量名&gt;</code>。</p>

            <p>利用这一命令，我们可以实现简单的交互。例如，我们可以写一个简单的“应声虫”小程序，即当用户输入一个内容后，程序原封不动将其输出。</p>

            <pre><code>
#!/bin/bash
# 读取输入
read -p "Please input a string: " STRING
# 输出
echo "You said: ${STRING}."
echo "Good Luck!"
            </code></pre>

            <p>其中，第3行我们使用<code>read</code>命令读取用户输入，并将其赋值给<code>STRING</code>。之后在第5行使用<code>echo</code>语句输出了用户的内容（在前面加了一些其他内容）。</p>

            <p>在运行时，程序会首先输出<code>Please input a string: </code>并等待用户输入。当用户输入完毕后，按下回车表示完成，此时程序执行后面的内容（输出）。</p>

            <div class="attention">
                <p>在读取输入时，不要在变量名前面“画蛇添足”加上一个<code>$</code>符号。如果你试着这样做，会得到错误的结果——它有可能会输出空白信息，或者输出一些其他的内容。</p>
            </div>

            <div class="extend">
                <p>输出空白或者其他信息取决于你的运行方式是使用<code>source</code>还是添加执行权限。对于前者，<code>source</code>本质上相当于在当前Shell终端下执行了脚本里的命令，其变量会延续到脚本外。因此，如果你在刚开始正确时输入了一个内容，如“Hello World!”，脚本会将其赋值给<code>STRING</code>变量并延续到Shell外部（用更专业的说法，这种“延续”实际上是“作用域”的体现）。此时如果你尝试在外面直接运行<code>echo $STRING</code>，也会得到对应的结果。</p>

                <p>如果你是添加了执行权限并运行的话，脚本实际上是在当前Shell下新建了一个“子Shell”并运行，运行过程中产生的变量仅会在这一Shell内有效（表现为程序内），当退出脚本时，变量也就因此失效了。</p>

                <p>在使用<code>read</code>输入变量时，如果后面加了<code>$</code>符号，则不会输入任何内容。此时在<code>echo $STRING</code>时，则会根据目前环境下已有的变量，输出对应的结果（已有的内容或空白）</p>
            </div>

            <h3 id="subsec:输入-参数输入">参数输入</h3>

            <p>除了使用前面所介绍的<code>read</code>方法在程序运行时读取用户输入，在有些时候可能也希望通过类似于参数调用的方式输入。可以类比一下最开始我们所接触到的如<code>cd</code>和<code>rm</code>，在切换目录或者删除文件时，都是在调用时直接给出对应的文件名，而不是在运行过程当中输入。那我们有没有类似的方法实现这一功能？</p>

            <p>答案肯定是有的，而且这一部分你不需要任何特殊的命令。因为在脚本中，如果调用时提供了一个参数，默认在程序中就是<code>$1</code>，以此类推，如果有两个或多个参数，则分别是<code>$2, $3, $4</code>等等。例如，下面的代码则实现了位置参数的调用：</p>

            <pre><code>
#!/bin/bash
# 输出第一个参数
echo "First parameter is ${1}"
# 输出第二个参数
echo "Second parameter is ${2}"
            </code></pre>

            <p>当调用时，类似于之前使用其他内置命令那样，可以往其中传递参数（使用空格分割），如<code>./loc_parameters hello world</code>，则第一个参数为“hello”，第二个参数为“world”。</p>

            <div class="attention">
                <p>通常来说，我们将这种形式上如<code>$n</code>的参数叫做<strong>位置参数</strong>。也请务必注意的一点是：位置参数默认是从1开始而不是从0开始的。当参数数量在9个及以内时，可以直接使用<code>$1</code>到<code>$9</code>这种形式，但如果到了10个及以上参数，需要在数字外面加大括号如<code>${10}</code>。</p>

                <p>你也可以尝试在程序中使用<code>$0</code>，它表示<strong>正在运行的脚本名称</strong>。</p>
            </div>

            <div class="extend">
                <p>如果你真的尝试输出<code>$0</code>的值，可能会意外地输出一个叫做<code>-bash</code>的内容而不是脚本名称。这是因为如果你使用的是<code>source</code>方式运行，在这种情况下，你的脚本实际上是在当前命令行环境下运行，此时程序中的<code>$0</code>与你直接在命令行中输入<code>$0</code>运行结果应当是一致的。</p>

                <p>另外，如果你的程序是在其他目录下运行（假设你已经将这一目录添加进环境变量），此时<code>$0</code>会输出这一脚本所在的完整目录。</p>
            </div>

            <p>除了直接使用位置编号表示参数本身外，Bash脚本还提供其他内置的参数表示其他信息。常见的例如<code>$#</code>表示传递的参数个数（不包括<code>$0</code>），<code>$@</code>表示整个参数列表。下面的程序使用<code>for</code>循环遍历了所有参数（完整的<code>for</code>循环教程在后面介绍）</p>

            <pre><code>
#!/bin/bash
# 输出一些特殊参数
echo "Current file is ${0}"
echo "We have $# parameters"
echo "They are:"
for i in $@ 
do
    echo $i
done
            </code></pre>

            <p>其中，第6行使用<code>$@</code>符号表示传入的参数列表，并对其中的所有元素进行遍历（输出）</p>

            <h3 id="subsec:输入-读取命令作为输入">读取命令作为输入</h3>

            <p>除了在运行时输入，在很多时候我们需要借助于一些命令读取文件的内容，并将其作为变量进行处理。例如，我们希望读取<code>INCAR</code>文件中的<code>ENCUT</code>所在的一行，根据前面所学习的方法，我们可以使用<code>grep</code>命令，如<code>grep ENCUT INCAR</code>命令来输出这一行。如果我们希望将这一命令作为变量输入到脚本中，只需要使用<code>$(grep ENCUT INCAR)</code>这种形式即可，其命令使用小括号，且前面加上变量的<code>$</code>符号。同样，在命令里面也可以使用变量以实现更复杂的交互功能，下面的代码实现了<strong>用户输入一个字符串和文件名，查找文件中包含这一字符串所在一行的内容</strong>：</p>

            <pre><code>
#!/bin/bash
# 读取字符串
read -p "Please input a string: " STRING
# 读取文件名
read -p "Please input a file name: " FILE
# 读取命令并赋值
result=$(grep ${STRING} ${FILE})
echo ${result}
            </code></pre>

            <div class="attention">
                <p>上述代码并不是一个“完美”的代码，因为在读取文件时，并没有对文件是否存在进行检查。因此，如果输入了一个不存在的文件名，则会输出错误的结果（如同你正常使用<code>grep</code>时输入了错误的文件名那样报错）。当你测试这一段代码时，请提前创建好一个对应的文件。</p>

                <p>在后面的学习中，我们将进一步完善这一代码（设置一段代码实现文件是否存在的检查）</p>
            </div>

            <footer>
                <p>注解：</p>
                <ol>
                <li id="ftnt1">尽管我们已经有了<code>rm</code>命令，但我们可能还会有其他想法。例如，我们希望在删除完成后输出删除了哪些文件，或者我们希望将“删除”改为移动至某一个目录实现“回收站”的功能。</li>
                </ol>
            </footer>

        </div>

        <div id="sec:判断语句" class="chapter-content" style="display: none;">
            <h2>判断语句</h2>
            <p><strong>作者：</strong> Jiaqi Z.</p>

            <h3>知识点</h3>
            <ul>
            <li>如何在脚本中使用<code>if</code>及相关语句</li>
            <li>如何对数值、字符串和文件进行判断</li>
            <li>如何进行逻辑判断（与、或、非）</li>
            </ul>

            <p>在之前的脚本中，我们只能按照顺序进行执行，从某种程度上来看，这并不“智能”。通常来说，一个好的脚本应该会根据实际情况来决定执行的内容，比如，当用户输入了一个文件名后，如果这个文件并不存在，程序应当做出相应的反馈。这一节，我们就会稍微了解以下如何进行判断，并且让程序根据情况做事。</p>

            <h3 id="subsec:判断语句-if语句"><code>if</code>语句</h3>

            <p>在开始这一切的学习之前，让我们先来了解一个最基本的判断语句框架，以便在后面更好地讨论深入的话题。类似于C语言和Python语言等，在Shell脚本中，最简单的判断语句（<code>if</code>语句）框架如下：</p>

            <pre><code>
commands1
if [ condition ]; then
    commands2
fi
commands3
            </code></pre>

            <img src="fig/if语句.png" width="20%" alt="if语句流程图">

            <p>这一段代码当执行完<code>commands1</code>之后，进行condition判断（条件是否成立），如果（if）成立，然后（then）执行<code>commands2</code>语句，<strong>否则不执行任何语句</strong>，最后执行<code>commands3</code>。</p>

            <div class="attention">
                <p>无论条件是否满足，<code>commands3</code>都会执行（它是if语句之外的内容，类似于<code>commands1</code>）。在这里的<code>commands1,commands2,commands3</code>都代表语句（们），每一部分可以是一条或多条语句。<code>condition</code>是<strong>判断条件</strong>，在后面的部分我们将详细介绍如何描述这一部分，简单来说，它描述的内容就是“是否……？”。</p>

                <p>需要特别注意<code>condition</code>前后与中括号之间的空格，这个空格不能省略！千万不要写成<code>[condition]</code>这种形式。</p>
            </div>

            <div class="extend">
                <p>与C语言使用大括号，Python语言使用缩进不同，Shell脚本采用类似于Basic语言和MATLAB那样使用语句表示一整个语句块的方式。一个判断语句一定是以<code>if</code>开始，以<code>fi</code>结束。这个<code>fi</code>不代表“finish”或者“final if”等类似含义，而是<code>if</code>的倒序（在后面其他内容的学习中，会逐渐印证这一点）。</p>

                <p>换言之，在上述代码中，使用缩进与否并不会影响脚本执行效果，但为了增强可读性，我们仍然建议<strong>使用缩进表示每一级之间的层级关系</strong>。事实上，如果你使用<code>vi</code>创建<code>*.sh</code>文件时，在输入<code>if</code>后默认会进行缩进，这也是大多数现代程序语言文本编辑器应当具有的功能。</p>
            </div>

            <h3 id="subsec:判断语句-关系运算符">关系运算符</h3>

            <p>任何一个分支判断语句，都应当首先给定一个关系运算，并根据这个结果来判断应该执行哪些命令。在Shell脚本中，我们大致可以将关系运算符分成三类：</p>

            <h4>整数比较</h4>

            <p>类似于数学上的大于、小于和等于，在Linux当中也有对数值的比较，包括等于（<code>-eq</code>, <code>==</code>）、不等于（<code>-ne</code>, <code>!=</code>）、大于（<code>-gt</code>, <code>&gt;</code>）、小于（<code>-lt</code>, <code>&lt;</code>）、大于等于（<code>-ge</code>）和小于等于（<code>-le</code>）六种。</p>

            <div class="attention">
                <p>在Shell脚本中，许多运算符都是通过上面这种“选项”的形式给出。与一般输入命令类似，选项前后也需要有空格进行分割。</p>

                <p>除了选项格式外，前四种（等于、不等于、大于和小于）我们也给出了类似于C和Python等其他编程语言所使用的运算符格式。这些在Shell脚本中同样可用。但是，对于大于等于和小于等于，没有<code>&gt;=</code>和<code>&lt;=</code>。如果你使用了这两个符号，大概率会报错。关于这一问题，目前还没有找到相关的解决方法，如果你有了对应解决方法（当然，不是后面要讲的内容），请联系我。</p>
            </div>

            <div class="extend">
                <p>这些选项实际上是英文单词的缩写，例如，<code>eq</code>=equal; <code>ne</code>=not equal; <code>gt</code>=greater than; <code>lt</code>=less than; <code>ge</code>=Greater or Equal; <code>le</code>=Less or equal</p>

                <p>在后面你还会见到其他类似的语句，了解它们的实际含义可以帮助你记忆这些选项。</p>
            </div>

            <p>下面的程序可以用来判断两个数字是否相等（使用前面的<code>if</code>语句）</p>

            <pre><code>
#!/bin/bash
# 判断两个数字是否相等
a=10
b=10
# if语句判断是否相等
if [ $a -eq $b ]; then
    echo "$a is equal to $b"
fi
# 判断结束后输出
echo "Bye!"
            </code></pre>

            <p>你可以试着修改变量的值，查看输出结果是否有不同。在上述代码中，当变量相等时，判断结果为“1”，从而执行里面的语句；如果不相等，则判断结果为“0”，跳过里面的语句。无论结果如何，你都会看见第10行所输出的“Bye!”（它在<code>if</code>语句外面）。</p>

            <div class="extend">
                <p>在这里我们提到了“1”和“0”，它们实际上叫做“<strong>布尔值</strong>”或者“<strong>逻辑值</strong>”，也是关系运算（与后面要提到的逻辑运算）的返回结果，其值只包含两种：“真”（也可以用“True”、“1”等代替）和“假”（也可以用“False”、“0”等代替）。</p>
            </div>

            <div class="attention">
                <p>在中括号里面表示条件判断时，请务必记得中括号内前后要加空格，同时<code>-eq</code>前后也要加空格。</p>

                <p>在完成<code>if</code>语句后，不要忘记后面的<code>fi</code>。</p>
            </div>

            <p>你也可以试着修改判断条件，例如改成<code>-gt</code>，并修改变量的值，查看结果。</p>

            <h4>*浮点数比较</h4>

            <div class="extend">
                <p>由于前面所介绍的浮点数在脚本中的局限性，这一部分内容关于浮点数的比较并非必须了解。但如果你确实有此方面需求，在确定不能使用其他如C和Python等编程语言实现的前提下，可以参考这一部分所介绍的方法。</p>

                <p>相比于前面的整数比较，浮点数比较<strong>不能使用</strong>前面的“选项”格式。例如，你写出<code>if [ 3.5 -ne 2.5 ]</code>是错误的。但是，前面所使用的运算符形式如<code>==, !=</code>等还是可用的。基于此，对于判断等于和不等于（包括大于和小于），最简单的方法就是使用如<code>if [ 3.5 != 2.5 ]</code>的格式。</p>

                <p>但是，对于大于等于和小于等于这两种情况，整数部分尚且还有选项可用，浮点数则完全没有对应的简单方法。参考前面<a href="#subsec:变量-变量简单运算">变量-变量简单运算</a>一节所介绍的<code>bc</code>命令，我们可以退而求其次，借助于逻辑运算符的输出结果1和0，来进行判断。例如，我们希望判断3.5是否大于等于2.5，则可以使用<code>if [ $(echo "3.5 &gt;= 2.5" | bc) -eq 1 ]</code>这种方式，其中小括号部分借助管道运算符和<code>bc</code>命令计算<code>3.5 &gt;= 2.5</code>的结果，根据前面所介绍的逻辑值，输出结果应当是0或1（在这里为1）。然后利用整数的判断方法，判断它与0或1的关系，从而实现浮点数对大于等于和小于等于的判断。</p>
            </div>

            <h4>字符串判断</h4>

            <p>与数值判断类似，字符串也可以进行相应的判断，一般常见的包括判断两个字符串是否相等（<code>==</code>），是否不相等（<code>!=</code>），以及判断一个字符串是否为空字符串（<code>-z</code>和<code>-n</code>）</p>

            <div class="attention">
                <p>在判断是否为空字符串时，可以使用<code>-z</code>和<code>-n</code>，二者在本质上判断的内容是一样的，但返回结果<strong>相反</strong>，前者当内容为空时返回“真”，后者当内容不为空时返回“真”。借助于后面的“求非”运算，这二者只需要有一个即可，但为了简洁易读，还是建议在对应的时候使用正确的关系运算符。</p>

                <p>此外，与前面数值判断不同，判断字符串是否为空是“一元运算符”，即<strong>只需要一个变量</strong>。后面的代码则给出了这种一元运算符的一般格式。</p>
            </div>

            <p>下面的代码实现了判断一个字符串是否为空字符串：</p>

            <pre><code>
#!/bin/bash
# 判断字符串是否为空
read -p "Please input a string:" string
# -n当字符串不为空时为真
if [ -n "$string" ]; then
    echo "Right! I got something ..."
    echo "You input: $string"
fi
echo "Bye!"
            </code></pre>

            <p>上述代码第5行通过<code>-n</code>判断输入字符串是否不为空，如果有内容（结果为真），则执行<code>if</code>语句里面的内容。</p>

            <div class="attention">
                <p>在对字符串进行判断时（包括使用二元关系运算符），请务必将字符串变量前后加上双引号。如果不加双引号可能会造成奇怪的错误。</p>
            </div>

            <h4>文件判断</h4>

            <p>Shell脚本也提供了大量的运算符选项，用来判断文件的相关信息。例如，使用<code>-e</code>判断文件<strong>是否存在</strong>，使用<code>-f</code>（<code>-d</code>）判断是否为普通文件（目录），使用<code>-r, -w, -x</code>依次判断文件是否可读、可写、可执行。</p>

            <p>与前面字符串的代码类似，这里的所有运算符都是一元运算符（即采用<code>&lt;选项&gt; 变量</code>的格式。例如，下面的代码简单实现了判断文件<code>INCAR</code>是否存在的功能：</p>

            <pre><code>
#!/bin/bash
# 判断文件INCAR是否存在
if [ -e "INCAR" ]; then
    echo "This file exists."
fi
echo "Bye!"
            </code></pre>

            <p>其中，<code>-e</code>后面的<code>"INCAR"</code>是指当前运行目录下的INCAR文件，你也可以使用绝对路径来描述文件。</p>

            <h3 id="subsec:判断语句-带有else的判断语句">带有<code>else</code>的判断语句</h3>

            <p>下面，我们将进一步介绍<code>if</code>语句，在之前我们仅仅用来判断某一个条件是否满足，且当满足时执行某一（些）语句。但有时，我们可能有更复杂的需求。例如，判断某一个文件是否存在，如果存在则对文件进行处理，如果不存在则输出文件不存在，并提示用户重新输入。我们姑且忽略到继续输入这一动作（需要用到后面的循环），当条件不满足时如何执行另外的语句？类似于其他编程语言，在Shell当中也可以使用<code>if-else</code>语句。其基本格式如下：</p>

            <pre><code>
commands1
if [ condition ]; then
    commands2
else
    commands3
fi
commands4
            </code></pre>

            <img src="fig/if-else语句.png" width="50%" alt="if-else语句">

            <p>首先程序会执行<code>commands1</code>，然后进行判断，如果（if）条件成立，则（then）执行<code>commands2</code>，否则（else）执行<code>commands3</code>。 无论结果如何，最后执行<code>commands4</code>。</p>

            <p>下面的代码则是利用上面的语法结构，对前面的判断文件是否存在的脚本进行了修改：</p>

            <pre><code>
#!/bin/bash
# 判断文件INCAR是否存在
if [ -e "INCAR" ]; then
    echo "This file exists."
else
    echo "This file NOT exists."
fi
echo "Bye!"
            </code></pre>

            <p>此之外，与Python语言类似，Shell脚本也有<code>if-elif-else</code>语句，用来对多条件进行判断，语法如下：</p>

            <pre><code>
commands1
if [ condition1 ]; then
    commands2
elif [ condition2 ]; then
    commands3
elif [ condition3 ]; then
    commands4
……
else
    commands5
fi
commands6
            </code></pre>

            <img src="fig/if-elif-else语句.png" width="40%" alt="if-elif-else语句">

            <p>程序首先判断<code>condition1</code>是否满足，如果（if）满足，则（then）执行<code>commands2</code>并结束判断语句，反之如果（else if, elif）满足<code>condition2</code>，则（then）执行<code>commands3</code>并结束判断语句；反之如果……；否则都不满足（else），执行<code>commands5</code>。在结束判断语句后，执行<code>commands6</code>。</p>

            <p>下面的程序可以用来判断两个整数之间的关系：</p>

            <pre><code>
#!/bin/bash
# 判断两个整数之间的关系
# 输入两个整数
read -p "Please input an integer(a): " a
read -p "Please input an integer(b): " b
# 判断两个整数之间的关系
if [ $a -eq $b ]; then
    echo "$a = $b"
elif [ $a -gt $b ]; then
    echo "$a &gt; $b"
else
    echo "$a &lt; $b"
fi
echo "Bye!"
            </code></pre>

            <h3 id="subsec:判断语句-嵌套if语句">嵌套<code>if</code>语句</h3>

            <p>与其他编程语言类似，脚本也可以使用嵌套的<code>if</code>语句，甚至可以更复杂的<code>if-elif-else</code>嵌套，基于此可以实现复杂的功能。在这里我们不举例子，但有一个需要特别注意的地方：</p>

            <div class="attention">
                <p>任何一个<code>if</code>语句，其后面都需要配合一个<code>fi</code>作为语句结束。尤其是对于嵌套时的<code>if-else</code>匹配问题，<code>else</code>总是与最近的未完成的<code>if</code>语句匹配（与缩进无关）。例如，下面的代码就违反了第一个原则（<code>if</code>必须配合有一个<code>fi</code>）；同时，看似<code>else</code>是属于<code>condition1</code>所对应的判断，但事实上是属于里面的<code>if</code>。</p>

                <pre><code>
if [ condition1 ]; then
    commands1
    if [ condition2 ]; then
        commands2
else
    commands3
fi
                </code></pre>

                <p>这段代码是无法正常运行的。所缺少的<code>fi</code>可以加在<code>commands2</code>后面，也可以加在<code>commands3</code>后面，二者所实现的效果是不一样的。你可以尝试一下不同位置所对应的程序运行结果。</p>

            </div>

            <h3 id="subsec:判断语句-逻辑运算">逻辑运算</h3>

            <p>在这一节的最后，让我们再来讨论一下逻辑运算。逻辑运算一共分为三种：与（<code>-a</code>）、或（<code>-o</code>）和非（<code>-n</code>）。其中与运算和或运算都是二元运算符，而非运算是一元运算符。</p>

            <p>对于与运算而言，<strong>只有当两个值都为真时结果为真</strong>。而对于或运算，<strong>只要有一个为真，结果为真</strong><sup>1</sup>。对于非运算，是一元运算符，其运算结果就是<strong>真变假，假变真</strong>。</p>

            <p>下面一个例子实现了判断三个数字是否从小大大排序：</p>

            <pre><code>
#!/bin/bash
# 判断三个数字是否从小到大排序
a=5
b=8
c=10
# 使用与运算符连接
if [ $a -le $b -a $b -le $c ]; then
    echo "$a, $b, $c"
fi
            </code></pre>

            <div class="extend">
                <p>在这里我们使用多个运算符进行连接，与其他编程语言类似，这里也具有“优先级”的问题。可以简单的理解：关系运算符的优先级高于逻辑运算符的优先级（这在大多数编程语言中都是如此）。虽然上面的写法比较简单，但对于条件复杂的时候可能不具有较好的可读性。因此，可以使用类似于C语言的运算符（<code>&&</code>表示“与”，<code>||</code>表示“或”），而中间每一个条件使用中括号分割，写作<code>if [ $a -le $b ] && [ $b -le $c ]</code></p>
            </div>


            <h3 id="subsec:判断语句-错误处理">错误处理</h3>

            <p>这一部分有可能出现的错误太多了，以至于难以在这里全部列出。这里仅列举一些常见的错误，且这些错误的解决方法仅是一部分可能的原因。当你出现错误时，请首先查看对应的格式是否正确，并且可以尝试联系我们。</p>

            <h4>-bash: &lt;文件名&gt;: line &lt;行号&gt;: syntax error: unexpected end of file</h4>

            <p>这是因为在使用<code>if</code>后没有对应的<code>fi</code>作为结束。通常出现在嵌套语句中或者一个<code>if</code>语句太长，到最后忘记了匹配。对此，我们建议，在开始就按照<code>if-fi</code>对应关系输入。</p>

            <h4>bash: [&lt;变量&gt;: command not found...</h4>

            <p>这可能是由于你在输入关系表达式时忘记了中括号里前后要加空格。</p>

            <h4>-bash: [: missing `]'</h4>
            <p>与前面的错误类似，这个通常指右中括号前面没有空格。</p>

            <footer>
                <p>注解：</p>
                <ol>
                <li id="ftnt1">或者还有一种表述是，只有当两个值都为假时，结果为假。</li>
                </ol>
            </footer>

        </div>

        <div id="sec:case分支语句" class="chapter-content" style="display: none;">
            <h2><code>case</code>分支语句</h2>
            <p><strong>作者：</strong> Jiaqi Z.</p>

            <h3>知识点</h3>
            <ul>
            <li>如何使用<code>case</code>语句实现分支判断</li>
            </ul>

            <p>在前面的<code>if</code>语句中，已经了解了如何进行判断。理论上了解了<code>if</code>语句后可以解决所有分支情况，但是有一些情况可能比较特殊。例如，我们希望实现一个菜单界面，此时可能需要用户输入一些指令表示对应的功能。可以想见，如果使用<code>if</code>语句，将会有许多的判断条件，甚至随着条件的增多，也会影响程序运行效率<sup>1</sup>。</p>

            <p>因此，我们希望可以寻找一种方法，直接对变量进行判断，并根据它的值选择合适的语句执行。可以猜到，这就是本节<code>case</code>语句所要解决的问题。</p>

            <h3 id="subsec:case分支语句-case语句基本结构"><code>case</code>语句基本结构</h3>

            <p>类似于<code>if</code>判断语句，<code>case</code>判断语句的基本结构为：</p>

            <pre><code>
case &lt;变量&gt; in
pattern1)
    statements1
    ;;
pattern2)
    statements2
    ;;
......
*)
    statements3
    ;;
esac
            </code></pre>

            <p>程序会根据变量所在（in）的模式（可以是一个单独的值，或者正则表达式），选择合适的语句进行执行。例如，如果变量满足<code>pattern1</code>，则会执行<code>statements1</code>语句；如果满足<code>pattern2</code>，则会执行<code>statements2</code>语句；以此类推，如果所有的都不满足，则执行<code>*</code>所对应的<code>statements3</code>语句。</p>

            <div class="attention">
                <p>有几个细节需要特别关注：所有匹配模式都是以小括号作为结束分割（没有左括号）；当每一个分支里面的语句结束时，需要有<code>;;</code>作为结束的标志；在<code>case</code>语句结束时，需要有<code>esac</code>作为结束标志。</p>
            </div>

            <div class="extend">
                <p>正如在<a href="#sec:判断语句">判断语句</a>中所讲的那样，<code>esac</code>也是<code>case</code>的倒序。另外，模式当中的<code>*</code>实际上可以想见，表示的就是通配符里面的可以表示任意多个字符的<code>*</code>符号。</p>
            </div>

            <h3 id="subsec:case分支语句-case分支语句应用"><code>case</code>语句应用</h3>

            <p>下面让我们来看几个常见的应用例子。</p>

            <h4>单一字符匹配</h4>

            <p>在<code>case</code>语句中，最简单的就是对单独一个字符进行匹配。下面这个例子则实现了一个对菜单的模拟，用户通过输入1或者2来实现对应不同的功能。</p>

            <pre><code>
#!/bin/bash
# 模拟菜单选项
echo "--------------------"
echo "1) option 1"
echo "2) option 2"
echo "--------------------"
read -p "Please input a number: " number
case $number in
1)
    echo "You input 1"
    echo "I will do something for option 1..."
    ;;
2)
    echo "You input 2"
    echo "I will do something for option 2..."
    ;;
*)
    echo "You did NOT input 1 or 2"
    ;;
esac
echo "Bye!"
            </code></pre>

            <p>运行上面的代码，可以看见：当用户输入1时，程序可以直接跳转到<code>1)</code>所对应的语句；对应的，当用户输入2时，可以跳转到<code>2)</code>所对应的语句；如果输入其他内容（例如输入3），则会跳转到最后提示输入错误。</p>

            <div class="attention">
                <p>与<code>if</code>语句类似，<code>case</code>语句的前后，即开始的提示和后面的“Bye!”无论哪种情况都会输出，因为它们不属于<code>case</code>语句内。</p>
            </div>

            <h4>字符串匹配</h4>

            <p>字符串匹配与单一字符匹配完全一样（你可以将单个字符理解成一种特殊的字符串）。但是，在这里我们也有一点新东西要讲。如果我们希望多个选项匹配同一个分支，可以<strong>使用<code>|</code>符号表示“或”进行分隔</strong>。例如，下面的程序则是根据用户输入的字符串选择特定的分支（有时多个输入对应同一个分支）：</p>

            <pre><code>
#!/bin/bash
# 字符串匹配
read -p "Please input you favourite band: " band
case $band in
"PPP"|"ppp"|"Poppin'Party")
    echo "Thanks! I have known that you like Poppin'Party!"
    ;;
"Roselia"|"R")
    echo "Thanks! I have known that you like Roselia!"
    ;;
"RAS"|"RAISE A SUILEN"|"Raise a suilen")
    echo "Thanks! I have known that you like RAISE A SUILEN!"
    ;;
"MyGO!!!!!"|"mygo"|"mygo!!!!!")
    echo "Thanks! I have known that you like MyGO!!!!!"
    ;;
*)
    echo "Sorry...I don't know this band."
    echo "But now I have known it -- $band"
    echo "Thank you!"
    ;;
esac
echo "Bye!"
            </code></pre>

            <p>与前面的代码分析完全类似，但特别的是，这里面分支的判断使用<code>|</code>表示“或”，例如，“PPP”、“ppp”和“Poppin'Party”对应的都是同一个分支；类似地，“R”和“Roselia”也是对应同一个分支，当用户输入“R”或者输入“Roselia”时，得到的结果是一样的。</p>

            <h4>正则表达式匹配</h4>

            <p>正如一开始所说的那样，在匹配时可以使用<strong>正则表达式</strong>。例如，下面的代码试图读取用户输入的参数为字母还是数字<sup>2</sup>：</p>

            <pre><code>
#!/bin/bash
# 读取调用时的选项
export LC_ALL=C
case $1 in
[a-z])
    echo "You input a lowercase"
    ;;
[A-Z])
    echo "You input an uppercase"
    ;;
[1-9])
    echo "You input a number"
    ;;
*)
    echo "You input other things"
    ;;
esac
echo "Bye!"
            </code></pre>

            <div class="extend">
                <p>也许你足够灵敏，注意到了第3行的<code>export LC_ALL=C</code>，这句命令表示将程序运行语言环境设置为默认值（可以通过<code>locale</code>查看环境语言设置），其中<code>C</code>表示系统默认值。</p>
                
                <p>在这里我们需要添加这一行命令以确保程序运行正确，但这行命令并不影响我们对<code>case</code>的理解。</p>

                <p>同时，当你运行这一行代码之后，可能程序中的中文注释发生乱码，这并不影响程序运行结果，你可以重新启动系统以恢复开始的状态。</p>
            </div>

            <p>在调用时，当用户传递给一个小写字母时，则会匹配到<code>[a-z]</code>，相对地，若给定一个大写字母作为参数，则会匹配到<code>[A-Z]</code>。但是，我们这里只能对用户输入的一个参数进行判断，如果用户输入多个字符的参数（例如<code>abc</code>），程序则会认为输入了其他内容。如何修改程序呢？请自己思考并尝试写一段代码<sup>3</sup>，同时自己测试它。（为简单起见，我们只需要匹配第一个字符即可）</p>

            <p>同时，正则表达式也可以使用<code>|</code>作为分隔以进行多个情况的判断，例如，我们希望将上面的代码修改为无论大小写字母都判断为字母，则可以写成下面的样子：</p>

            <pre><code>
#!/bin/bash
# 读取调用时的选项
export LC_ALL=C
case $1 in
[a-z]|[A-Z])
    echo "You input a letter"
    ;;
[1-9])
    echo "You input a number"
    ;;
*)
    echo "You input other things"
    ;;
esac
echo "Bye!"
            </code></pre>

            <h3 id="subsec:分支语句-错误处理">错误处理</h3>

            <h4>-bash: &lt;文件名&gt;: line &lt;行号&gt;: syntax error near unexpected token `)'</h4>

            <p>这可能是因为你在结束分支时少了<code>;;</code>表示当前分支内结束。如果你了解C语言，你可能会很自然将这这个符号作为C语言中<code>switch-case</code>的<code>break</code>语句。但显然，C语言的<code>break</code>更加灵活（它可以没有从而越过其他分支），但Shell脚本不能没有<code>;;</code>结束。</p>

            <h4>-bash: &lt;文件名&gt;: line &lt;行号&gt;: syntax error near unexpected token `&lt;字符串&gt;'</h4>

            <p>这可能是由于你在使用<code>case</code>语句后忘记结束<code>esac</code>而后面还有其他语句从而报错。如果后面没有语句，则可能会出现下面的错误：</p>

            <h4>-bash: &lt;文件名&gt;: line &lt;行号&gt;: syntax error: unexpected end of file</h4>

            <p>这也表明你可能没有使用<code>esac</code>作为<code>case</code>语句的结束。</p>

            <footer>
                <p>注解：</p>
                <ol>
                <li id="ftnt1">这是因为在进行判断时，脚本需要对所有条件进行遍历。</li>
                <li id="ftnt2">为了复习之前的变量种类，我们在这里尝试使用参数给定变量而不是使用<code>read</code>命令。</li>
                <li id="ftnt3">请真的这样做，这会极大提高你的编程思维。</li>
                </ol>
            </footer>
        </div>

        <div id="sec:循环" class="chapter-content" style="display: none;">
            <h2>循环</h2>
            <p><strong>作者：</strong> Jiaqi Z.</p>

            <h3>知识点</h3>
            <ul>
            <li>如何使用<code>for</code>循环</li>
            <li>如何使用<code>while</code>循环</li>
            <li>如何使用<code>until</code>循环</li>
            <li><code>while</code>循环和<code>until</code>循环的区别</li>
            </ul>

            <p>在前面介绍高级Linux命令时，我们曾说过脚本处理的任务大多是<strong>批量处理</strong>任务，而批量处理的一个基本方法就是使用循环语句（毕竟没有人会想写上上百行相同的代码）。在<a href="#sec:简单for循环">简单for循环</a>一节中，我们介绍过<code>for</code>循环的使用，当时是在命令行中编写的。本节我们将首先复习一下<code>for</code>循环的基本使用方法，以及它在脚本程序中的格式（和命令行类似），然后再介绍两种不同的循环语句——<code>while</code>循环和<code>until</code>循环——它们虽然在一定程度上是等价的，但在不同的情况下，选择合适的循环语句会让程序更加简洁易读。</p>

            <h3 id="subsec:循环-for循环"><code>for</code>循环</h3>

            <p>下面的代码完整演示了常见的三种<code>for</code>循环格式：</p>

            <pre><code>
#!/bin/bash
# 使用for循环输出
# 简单列表
for i in 1 2
do
    echo $i
done
echo ""
# 生成列表
for i in $(seq 1 2 10)
do
    echo $i
done
echo ""
# 使用C语言格式
for ((i=0;i&lt;10;i++))
do
    echo $i
done
            </code></pre>

            <p>其中第8行、第14行使用<code>echo ""</code>输出一个空行用来区分不同的输出结果。</p>

            <h4>简单列表</h4>

            <p>使用基本列表的格式调用<code>for</code>循环的基本格式为：</p>

            <pre><code>
for &lt;变量名&gt; in &lt;列表&gt;
do
    循环体
done
            </code></pre>

            <div class="extend">
                <p>在循环语句内部的语句，我们常常称其为<strong>循环体</strong>（实际上和前面所说的<code>commands</code>，程序块，语句块等一样）</p>
            </div>

            <p>在这里的<code>&lt;列表&gt;</code>可以如同上面的代码一样直接以空格分隔表示，也可以与<a href="#sec:简单for循环">简单for循环</a>一节所说的那样使用大括号将其括起来，并用逗号分割。</p>

            <div class="attention">
                <p>一个常见的错误是将两者混淆，即<strong>使用大括号表示列表的同时，其内部元素用空格分隔</strong>。可以验证的是，这并不会如你所愿得到正确的信息。事实上，空格的“优先级”会高于大括号的“优先级”（这里加引号表示这不是传统意义上运算符的优先级），当括号和空格同时存在时，程序会将列表解析为<strong>以空格分隔的列表</strong>，从而在输出的前后（第一个元素和最后一个元素）带有大括号。</p>
            </div>

            <p>与前面的介绍类似，在循环体内使用变量需要加<code>$</code>符号。</p>

            <h4>生成列表</h4>

            <p>与<a href="#sec:简单for循环">简单for循环</a>里所介绍的方法类似，可以使用<code>seq</code>命令生成序列。与前面所介绍的方法不同的是，前面所使用的是<code>`</code>符号括起来的命令，而在脚本中，由于将<code>seq</code>看作是一个命令，因此与前面<a href="#subsec:输入-读取命令作为输入">输入-读取命令作为输入</a>一节所介绍的输入方式类似，使用<code>$()</code>的方式得到<code>seq</code>命令的结果，并将其作为一个变量传递给<code>for</code>循环。</p>

            <p>当然，也可以使用前面所说的<code>..</code>的方式生成序列。但需要复习的是：对于<code>seq</code>语句而言，三个参数分别是<strong>开始、步长、结束</strong>；而对<code>..</code>方式而言，三个参数分别是<strong>开始、结束、步长</strong>。因此，上面代码的<code>seq 1 2 10</code>也可以写作<code>{1..10..2}</code></p>

            <h4>运算格式生成</h4>

            <p>如果你熟悉C语言的话，这一种格式会显得很“亲切”。因为它的基本结构与C语言几乎完全类似，类似地写法，如果让我们用C语言实现上面代码的第3部分，则可以写作这样：</p>

            <pre><code>
#include &lt;stdio.h&gt;
void main()
{
    for (int i=0;i&lt;10;i++)
        printf("%d\n",i);
}
            </code></pre>

            <p>可以看到，相比于C语言，脚本只是一个括号和两个括号的区别<sup>1</sup>。</p>

            <div class="attention">
                <p>在脚本的<code>for</code>循环当中，括号前面没有<code>$</code>符号，也千万不要“画蛇添足”加上这个符号。</p>
            </div>



            <h3 id="subsec:循环-while循环"><code>while</code>循环</h3>

            <p>与C语言的<code>while</code>循环类似，在bash脚本中也存在根据条件判断循环与否的<code>while</code>循环。其基本格式如下：</p>

            <pre><code>
while [ condition ]
do
    循环体
done
            </code></pre>

            <p>其中，<code>condition</code>表示<strong>循环进行的条件</strong>，其格式与<a href="#sec:判断语句">判断语句</a>当中所介绍的条件表达式类似。例如，下面的代码实现了从0到9的输出</p>

            <pre><code>
#!/bin/bash
# 使用while循环输出数字
i=0
while [ $i -lt 10 ]
do
    echo $i
    ((i++))
done
            </code></pre>

            <p>可以复习一下，条件<code>-lt</code>表示<strong>小于</strong>，因此，循环体进行的条件是<strong>变量<code>i</code>小于10</strong>。当条件满足时，程序进行循环体（<code>do</code>和<code>done</code>中间的部分）。因此，程序会从0开始，逐渐输出并加1，直到条件不满足时（<code>i</code>为10）则停止循环。</p>

            <div class="attention">
                <p>与<code>for</code>循环相比，<code>while</code>循环更有可能写出“死循环”语句。所谓“死循环”，指的是程序在循环体内一直循环，永无停止。在上面的代码中，如果少了那句<code>((i++))</code>，则变量始终为0，条件始终满足，从而无法停止。</p>

                <p>具体的解决方法，可以见下一节所介绍的<code>break</code>和<code>continue</code>语句。</p>

                <p>在实际操作中，如果出现死循环导致程序无法停止，则可以使用<code>Ctrl+C</code>快捷键终止当前命令。</p>
            </div>

            <p>此外，在上面程序的第7行，使用<code>((i++))</code>表示进行计算，这是比较简洁的C风格递增运算符，类似的还有递减运算符<code>--</code>。这种方式的使用需要以两个括号括起来。你也可以使用<a href="#sec:变量">变量</a>一节所介绍的方法，使用<code>i=$(( $i + 1 ))</code>的方式。这二者在这一功能上是等价的。</p>

            <h3 id="subsec:循环-until循环"><code>until</code>循环</h3>

            <p>与<code>while</code>循环几乎完全类似，bash脚本中<code>until</code>循环的格式为：</p>

            <pre><code>
until [ condition ]
do
    循环体
done
            </code></pre>

            <p>与上面的<code>while</code>循环格式比较可以发现，除了关键字从<code>while</code>变成了<code>until</code>外，其他语句在格式上没有任何不同。但<code>until</code>循环的最大特点是：<strong>循环体执行的条件是<code>condition</code>为假</strong>，即你可以简单的将其理解为：循环体会一直执行，“直到”（until）条件为真。</p>

            <div class="attention">
                <p>这一点稍微有点绕，但上面的两种表述是“等价”的。对<code>while</code>循环而言，当条件为真时执行循环体，而对<code>until</code>循环而言，当条件为真时退出循环（当条件为假时进入循环）</p>
            </div>

            <div class="extend">
                <p>在C语言中，确实没有类似的循环与其对应，但我们可以从其他一些编程语言中找到这个例子，一个最简单的例子就是——Visual Basic语言（简称VB语言）。在VB语言中，也存在类似的<code>until</code>循环，其格式为：</p>

                <pre><code>
Do 
    循环体
Loop Until 条件
            </code></pre>

                <p>如果你熟悉VB语言的话，bash脚本的<code>until</code>循环与VB语言的<code>until</code>循环最大的不同在于<strong>VB语言的条件是放在循环后面（类似于C语言的<code>do-while</code>循环）</strong></p>

                <p>当然，如果你不熟悉VB语言的话，也不必担心。这一部分仅仅是对那些熟悉VB语言的读者所准备的，以防他们混淆条件的位置。如果你本来不了解VB语言的话，这一部分完全可以跳过。</p>
            </div>

            <p>可以简单想见的是，<code>while</code>循环和<code>until</code>循环之间的转换仅仅是“<strong>条件的取反</strong>”，例如，上面关于<code>while</code>循环的例子，我们只需要将里面的条件<code>$i -lt 10</code>改为<code>$i -ge 10</code>，同时将<code>while</code>改为<code>until</code>就可以实现相同的功能。这一部分代码我们不做演示，请自己尝试修改上面的代码并测试其输出结果是否与之前的结果一致。</p>

            <footer>
                <p>注解：</p>
                <ol>
                <li id="ftnt1">由于C语言是强类型语言，因此在for循环条件中定义了变量类型<code>int</code>，但这不是必需的，因为完全可以将变量定义放在循环外面作为单独的语句，此时C语言的括号内与脚本的括号内就完全相同了。在比较二者不同时，我们有意忽略了这一点，只是为了让大家关注到本质</li>
                </ol>
            </footer>

        </div>

        <div id="sec:循环控制" class="chapter-content" style="display: none;">

            <h2>循环控制</h2>
            <p><strong>作者：</strong> Jiaqi Z.</p>

            <h3>知识点</h3>
            <ul>
            <li>如何使用<code>break</code>语句</li>
            <li>如何使用<code>continue</code>语句</li>
            </ul>

            <p>在<a href="#sec:循环">循环</a>一节中，我们曾简单提到了“死循环”问题。在当时看来，死循环是一个应当避免的“错误”，但事实可能不总是如此——在有些情况下，我们可能不得不希望使用死循环。例如，我们希望一直读取用户的输入，直到用户输入0时退出。此时当然可以使用<code>while</code>循环或者<code>until</code>循环来解决这一问题。但还有一种思路——设计一个死循环，当用户输入0时跳出循环。</p>

            <div class="extend">
                <p>在其他领域，死循环可能是更常见的。例如，在一些单片机系统中，会使用死循环来执行对应的任务，例如读取传感器数据、显示处理数据等；而在Windows操作系统中，任何一个窗口在创建时都会启动叫做“消息循环”的死循环来保持窗口——对于Windows来说，如果没有这个死循环，窗口会立即关闭。</p>

                <p>因此，在程序中，死循环并不是“绝对的错误”，而要根据需要选择。一些可控的、必需的死循环也是程序所必要的一部分。</p>
            </div>

            <p>回到最开始的例子，在bash语言中，我们有两种方式对循环语句进行控制——<code>break</code>语句和<code>continue</code>语句。其中前者表示“终止循环”，而后者表示“继续循环”</p>



            <h3 id="subsec:循环控制-使用break停止循环">使用<code>break</code>停止循环</h3>

            <div class="extend">
                <p>本节所要介绍的<code>break</code>与<code>continue</code>，在使用方式与效果上与C语言的<code>break</code>和<code>continue</code><strong>完全相同</strong>。因此，如果你足够熟悉C语言，本节完全可以跳过。但我们还是建议你通过阅读这一节复习一下相关的内容。</p>
            </div>

            <p><code>break</code>语句的作用是用来<strong>跳出循环</strong>，例如，下面的程序，用户输入一系列数字，当用户输入0时，循环结束，输出“end”</p>

            <pre><code>
#!/bin/bash
# break跳出循环
read a
while [ true ]
do
    if [ $a -eq 0 ]; then
        break
    fi
    echo $a
    read a
done
echo "end"
            </code></pre>

            <p>在第4行，我们设置了一个条件<code>true</code>，使循环条件始终成立，从而令其成为一个“死循环”。在第6行利用<code>if</code>语句判断输入的变量是否为0，如果是0，则通过<code>break</code>跳出循环，执行最后一行的“end”输出。如果输入的数字不为0，则输出对应的变量值。</p>

            <div class="attention">
                <p>请务必仔细思考一下，程序的第10行又写了一句<code>read a</code>有什么作用？如果没有这句命令会发生什么？在程序中有两句<code>read</code>命令稍显繁琐，有没有简单的方法使用一句即可实现相同的功能？</p>
            </div>

            <p>除了在<code>while</code>循环外，<code>for</code>循环和<code>until</code>循环也可以使用<code>break</code>语句。例如，下面的程序遍历了10-20之间所有的数字，且当数字为7的倍数时停止。</p>

            <pre><code>
#!/bin/bash
# 在for循环中使用break语句
# 当遍历到7的倍数时停止
for i in {10..20}
do
    if [ $(( $i%7 )) -eq 0 ]; then
        break
    fi
    echo $i
done
echo "end" 
            </code></pre>

            <p>其中，变量<code>i</code>会依次从10递增到20，当<code>i</code>取值为14时，满足7的倍数<sup>1</sup>，从而进入条件判断内，执行<code>break</code>命令，跳出循环输出<code>end</code></p>

            <div class="attention">
                <p>上面的两个例子还说明了，<code>break</code>跳出循环是“立刻跳出”，即如果循环体内有剩下的其他语句也不会执行了。例如，上面的判断倍数的例子，当<code>i</code>取值为14时，也没有输出这个值（因为输出命令在<code>break</code>后面。</p>

                <p>可以尝试一下：如果将<code>echo $i</code>放在循环体内第一行，输出结果会有什么不同？</p>
            </div>

            <h3 id="subsec:循环控制-使用continue跳过循环">使用<code>continue</code>跳过循环</h3>

            <p>与C语言类似，在bash脚本中，也可以使用<code>continue</code>跳过循环。这里所说的“跳过”，指的是<strong>跳过当前轮次的循环</strong>。让我们直接来看一个例子——假设将上面判断7的倍数的例子中的<code>break</code>改成<code>continue</code>，看看会发生什么。</p>

            <pre><code>
#!/bin/bash
# 使用continue语句跳过循环
for i in {10..20}
do
    if [ $(( $i%7 )) -eq 0 ]; then
        continue
    fi
    echo $i
done
echo "end" 
            </code></pre>

            <p>运行后可以看见，程序输出了10-20的所有数字，除了14。这是因为当变量<code>i</code>为14时，条件满足，执行<code>continue</code>语句，跳过了当前轮次的循环，直接进入下一个循环轮。与<code>break</code>类似，这里也不再执行后面的语句（即不会输出14这个数字）</p>

            <p>虽然<code>continue</code>在语法上和<code>break</code>类似，难度也不大，但其使用时存在一个非常潜在的“隐患”。让我们再来看一下本节最开始的程序，如果将其中的<code>break</code>改成<code>continue</code>，会发生什么？此时代码长成下面这样：</p>

            <pre><code>
#!/bin/bash
# 使用continue跳过0的判断，继续输入？
read a
while [ true ]
do
    if [ $a -eq 0 ]; then
        continue
    fi
    echo $a
    read a
done
echo "end"
            </code></pre>

            <p>一些“粗心大意”的人可能会认为：这段代码一直读取用户的输入并输出对应的内容，当用户输入0时跳过输出。让我们执行一下这段代码，当用户输入非0的数字时，程序很正常地输出对应的数字；当用户输入0时，程序也确实跳过了0的输出；但是，<strong>从这开始程序再也读取不了输入了</strong>。从程序代码的执行过程可以很容易理解这一点，当用户输入0时，此时变量<code>a</code>的值为0，进入条件判断内，跳过当前循环。正如前面所说的那样，程序跳过循环<strong>不再执行后面的语句</strong>。因此，在后面的循环中变量<code>a</code>始终保持0的值，即始终在4-7行语句间循环。</p>

            <div class="attention">
                <p>对于<code>for</code>循环而言，由于它是对序列进行遍历，一般情况下总是“有限”的，因此循环总是能停止的。而对于<code>while</code>和<code>until</code>循环而言，在循环开始和<code>continue</code>中间，<strong>要有改变循环条件或者终止循环的语句</strong>，否则循环将陷入“死循环”。</p>
            </div>
            
            <footer>
                <p>注解：</p>
                <ol>
                <li id="ftnt1">这里使用常见的方法——“取余”判断倍数，具体的计算方法可以查看<a href="#subsec:变量-变量简单运算">变量-变量简单运算</a>一节。</li>
                </ol>
            </footer>

        </div>

        <div id="sec:函数" class="chapter-content" style="display: none;">
            
            <h2>*函数</h2>
            <p><strong>作者：</strong> Jiaqi Z.</p>

            <h3>知识点</h3>
            <ul>
            <li>如何定义与调用函数</li>
            <li>函数参数</li>
            <li>函数返回值</li>
            </ul>

            <p>前面我们已经学习了程序的基本结构——顺序语句、条件语句和循环语句。此时，应当已经足够完成大多数脚本程序的编写。在本节和下一节，我们将介绍一些扩展性的内容——函数和数组。这两部分可以帮助你更快、更方便地编写程序。</p>

            <h3 id="subsec:函数-定义函数">定义函数</h3>

            <p>在bash脚本中，函数的定义必须在调用之前。这是因为脚本语言是按照顺序执行的，如果在程序不知道的情况下直接调用，那必然会报错。在bash脚本中，对一个函数定义的基本格式为：</p>

            <pre><code>
[function] function_name()
{
    函数体;
    [return int.;]
}
            </code></pre>

            <p>在定义时，可以在前面加上<code>function</code>以示区分，也可以不加直接以函数名作为开始。在函数内部的语句块使用大括号括起来（函数体），在函数的结束可以使用<code>return</code>语句返回一个范围在0-255之间的整数。</p>

            <div class="attention">
                <p>与大多数程序语言不一样，bash脚本对函数返回类型有明确的数值要求，且这个要求是不随程序员所改变的。如果要返回函数运行结果是否成功，可以使用<code>return</code>语句，但如果返回的是其他内容（例如返回两个数字相乘的结果），则可以使用字符串的形式返回。</p>

                <p>在bash的函数定义中，我们不会在函数开始的地方强调参数的个数和类型（这点与C语言等类似语言不同），具体的参数将在函数体内部使用<code>${num}</code>的形式体现（与<a href="#subsec:输入-参数输入">输入-参数输入</a>所介绍的参数类似）</p>
            </div>

            <p>例如，下面的程序简单定义了一个名字叫做<code>my_echo</code>的函数：</p>

            <pre><code>
#!/bin/bash
# 定义函数
my_echo()
{
    echo "Hello"
}
            </code></pre>

            <p>这个函数内部只有一个输出语句，且没有返回值。</p>

            <div class="extend">
                <p>我们这里所说的“没有返回值”，特别指的是不使用<code>return</code>返回的返回值。你也完全可以将这个函数的<code>echo</code>输出看作是一个字符串返回。</p>
            </div>

            <h4>有参数函数的调用</h4>

            <p>与<a href="#subsec:输入-参数输入">输入-参数输入</a>一节所介绍的方法类似，在函数内部我们也可以使用<code>$1</code>表示第一个参数，当参数个数大于等于10时，则需要使用大括号将数字括起来，例如，<code>${10}</code>表示第10个参数。</p>

            <p>在函数体内部，我们也可以使用<code>$#</code>表示参数的个数（与前面所介绍的方法一样），可以使用<code>$*</code>将所有参数以字符串的方式输出。例如，下面的程序就实现了两个整数相加的计算函数：</p>

            <pre><code>
#!/bin/bash
# 两个整数相加
function add_function() {
    c=$(( $1 + $2 ))
    echo $c
}
            </code></pre>

            <p>这里的第4行我们使用<code>$1</code>和<code>$2</code>分别表示第1个参数和第2个参数，并将计算结果赋值给变量<code>c</code>，并在最后输出变量<code>c</code>的值。</p>

            <p>在这里请思考一下：为什么我们的程序使用<code>echo</code>语句输出返回值，而不是使用<code>return</code>语句返回结果？</p>

            <details>

                <summary>答案</summary>

                因为两个数字相加的结果可能超过255。

            </details>


            <h3 id="subsec:函数-函数调用">函数调用</h3>

            <p>在定义函数的基础上，调用函数就可以将函数看作是一个新的<strong>命令</strong>使用了。例如，对于我们定义的<code>my_echo</code>函数，在程序内就可以直接使用<code>my_echo</code>命令调用这个函数，从而输出“Hello”。</p>

            <p>对于下面的<code>add_function</code>函数，类似于前面在介绍命令行传递参数一样，我们也可以使用类似的方式调用这个函数。下面的代码则完整展示了函数定义与调用的全过程：</p>

            <pre><code>
#!/bin/bash
# 两个整数相加
function add_function() {
    c=$(( $1 + $2 ))
    echo $c
}
result=$(add_function 200 300)
echo ${result}
            </code></pre>

            <p>我们在第7行使用了一个赋值语句特别说明了<strong>如何将函数<code>echo</code>的返回值作为一般的返回值处理</strong>，也可以看到，对于这个例子，当计算200+300时，程序可以给出正确的结果（500）。</p>

            <p>在一般使用时，我们也可以直接省略掉后面两行，而直接使用<code>add_function 200 300</code>也能输出类似的结果，当然，本例所给的方式更具有可扩展性。例如，你可以对这个结果进行进一步的计算，例如判断它是否大于255.（请试着完成这段代码）</p>

            <p>最后，让我们再稍微扩展一下，如果用户在最开始给定一个数字个数，使用上面的函数，实现多个整数相加的结果。例如，用户一开始输入5表示有5个整数进行相加，然后会依次输入5个整数，程序输出5个数字相加的结果。我们在这里给出最终答案，请试着理解这段代码，并在理解后尝试自己写出来实现相同的效果：</p>

            <pre><code>
#!/bin/bash
# 多个整数相加
function add_function() {
    c=$(( $1 + $2 ))
    echo $c
}

read -p "Please input a number" count
index=1
a=0
while [ $index -le $count ]
do
    read b
    result=$(add_function $a $b)
    a=$result
    ((index++))
done
echo $result
            </code></pre>

            <p>在分析这段代码时，请务必考虑的内容是：<code>while</code>内部的循环条件为什么是这样（如果写成<code>-lt</code>会发生什么）；为什么第15行要有一句<code>a=$result</code>，它的作用是什么？在整个程序中，<code>index</code>变量的作用是什么，为什么它的初始值设置为1；同时，为什么在开始时<code>a</code>有一个初始为0的值？</p>

            <p>当你想明白这些答案时，相信这段代码就没有难度了。当然，我们这里是逐一计算的，那有没有办法在存下多个数据后一次性计算呢？这里的难点在于如何存储多个数据，这就需要下一节<strong>数组</strong>相关的内容了。</p>

        </div>

        <div id="sec:数组" class="chapter-content" style="display: none;">
            
            <h2>*数组</h2>
            <p><strong>作者：</strong> Jiaqi Z.</p>

            <h3>知识点</h3>
            <ul>
            <li>如何初始化定义数组</li>
            <li>如何调用数组的元素</li>
            <li>如何定义“关联数组”</li>
            </ul>

            <p>在上一节的最后，我们提到：需要有一种手段保存所有的元素。这在当时是一种可选的手段，除此之外，还有一个更常见的例子：假设我们现在需要计算一个班级所有同学考试的平均分，并在最后输出高于平均分的分数。此时，寻找一个方法用来存放所有数据就是必要的了。而与其他编程语言类似，在bash脚本中，也有类似于“数组”这样的数据结构。</p>

            <p>在本节，我们将介绍如何在程序中显式定义<sup>1</sup>一个数组，以及如何调用数组的元素；在最后，我们再简单讨论一下<strong>关联数组</strong>的内容，这是一个类似于Python中“字典”的哈希表（Hash Map）结构。</p>

            <h3 id="subsec:数组-定义数组">定义数组</h3>

            <p>定义数组的方法并不困难，其基本格式为<code>&lt;变量名&gt;=(value1 value2 value3 ...)</code>，其中数组变量元素整体用小括号括起来，且各个元素之间用空格间隔。例如，下面的程序我们定义了一个数组：</p>

            <pre><code>
#!/bin/bash
# 定义数组
array1=(1 2 3 4 5)
array2=("Hello" "World")
array3=("Hello" 3 true)
            </code></pre>

            <p>在这段代码中，我们定义了三个数组，第一个数组<code>array1</code>和第二个数组<code>array2</code>分别是由数字和字符串组成的数组。在bash脚本中，数组不仅仅可以是数字，也可以是字符串或者其他数据类型。与C语言固定数组类型不同，在bash脚本中，一个数组内可以有多个数据类型，正如<code>array3</code>数组所演示的那样，其中可以包括字符串、数字、甚至逻辑值，都是可以放在一个数组变量下。</p>

            <div class="attention">
                <p>在定义数组时，与C语言不同，bash脚本不需要提供数组长度。换句话说，bash脚本的数组是<strong>可变长度</strong>的数组。</p>

                <p>而且，与其他编程语言不同，bash脚本仅支持<strong>一维数组</strong>。</p>
            </div>

            <h3 id="subsec:数组-数组调用">数组调用</h3>

            <p>与C语言类似的是，数组调用也是采用<code>&lt;数组名&gt;[下标]</code>的格式，其中下标是使用<strong>中括号</strong>括起来。一般数组的调用分为“读取”和“写入”两种情况，我们将依次讨论这两种情况的区别。</p>

            <div class="attention">
                <p>一个很关键的事情是：数组下标始终是<strong>从0开始计数</strong>的，即<code>array1[0]</code>表示数组<code>array1</code>的第一个元素。这件事情几乎是当今所有编程语言的基础<sup>2</sup>。</p>
            </div>

            <h4>读取调用</h4>

            <p>下面的代码演示了如何读取数组的元素：</p>

            <pre><code>
#!/bin/bash
# 定义与调用数组
array1=(1 2 3 4 5)
array2=("Hello" "World")
array3=("Hello" 3 true)
# 调用数组
result=$(( ${array1[0]}+${array1[1]} )) 
echo $result
echo ${array2[0]}
if [ ${array3[2]} ]; then
    echo ${array3[0]}
fi
            </code></pre>

            <p>上面代码的第7、9、10行分别演示了三种常见的调用方式，分别是<strong>在表达式中调用；在语句中调用；在逻辑表达式中调用</strong>。可以发现，无论哪一种调用方式，其格式基本是一样的，因此，读者完全不必将其分类到如此精确的程度，只需要记住一个原则：<strong>在读取时需要加$符号和大括号</strong>即可。</p>

            <h4>写入调用</h4>

            <p>在必要的时候，我们也可以对已有的数组进行修改。例如，下面的代码是对上面代码的进一步补充，并在其中演示了如何修改数组的元素值：</p>

            <pre><code>
#!/bin/bash
# 定义与调用数组
array1=(1 2 3 4 5)
array2=("Hello" "World")
array3=("Hello" 3 true)
# 调用数组
array1[0]=5
result=$(( ${array1[0]}+${array1[1]} )) 
array1[5]=$result
result[1]=${array2[0]}
if [ ${array3[2]} ]; then
    array3[2]=false
fi
result[2]=${array3[2]}
for i in {0..2}
do
    echo ${result[$i]}
done
            </code></pre>

            <p>在程序的第8行，我们将数组元素当作一般的变量，并对其进行赋值。但稍有难度的是第9行和第10行，其中第9行明明数组的最大下标为4（想想为什么5个元素的最大下标为4），但我们却可以对下标为5的元素赋值。在bash脚本中，这可以视作<strong>添加元素</strong>。与Python等语言可能还需要类似于<code>append()</code>函数不同，bash脚本只需要如同正常的数组进行操作即可，程序会自动追加新的元素在对应的位置。</p>

            <p>更奇怪的是第10行代码：为什么<code>result</code>明明是一个普通变量，却可以带有下标追加新的元素？事实上，一个普通的变量也可以看作是一个<strong>长度为1的数组</strong>。正因如此，我们可以对普通变量如同数组般进行操作（追加新的元素），甚至对于普通的变量，例如定义了变量<code>a=5</code>，我们也可以使用<code>a[0]</code>来代表这个变量。</p>

            <div class="extend">
                <p>我们可以将整个数组看作一个一维的表格，其编号从0开始，每创建一个元素，就在对应位置加上内容。因此，你可以将下标设置成不连续的（例如，<code>array1[10]</code>是允许的，此时的数组如图所示）</p>

                <img src="fig/数组结构.png" alt="添加数组元素后数组内元素的值" width="50%">

                <p>正如图中所示的那样，数组前面也可以有元素（负下标），但这些除非特殊情况，否则不建议使用。同样，也正如你所见，对于没有的元素，其变量值为“空”。</p>
            </div>

            <p>除此之外，还有一些特别的方法对数组进行调用。例如，借助于<code>*</code>符号，我们可以获取数组内所有元素的值（其方法为<code>&lt;变量名&gt;[*]</code>；使用<code>#</code>符号可以获取数组的长度。例如，对于数组<code>array1</code>，可以通过<code>${#array1[*]}</code>的方式获取其数组长度。</p>

            <div class="extend">
                <p>关于获取数组长度的方法，实际上近似等价于在介绍参数时（<a href="#subsec:输入-参数输入">输入-参数输入</a>）所提到的<strong>判断参数个数</strong>的方法。也如同当时所介绍的方法一样，这里的<code>*</code>也可以换成<code>@</code>符号。</p>
            </div>

            <h3 id="subsec:数组-关联数组">*关联数组</h3>

            <div class="extend">
                <p>在创建数组时，默认都是以数字作为下标。类似于Python中的“字典”结构，在bash脚本中我们也可以创建带有“键值对”的哈希表结构，称为<strong>关联数组</strong>。在定义关联数组前，需要使用<code>declare -A</code>的方式声明这个数组是关联数组。之后，就可以在下标中使用其他类型的数据（如字符串）对数组内的元素进行赋值。例如，下面的代码演示了如何定义与调用关联数组：</p>

                <pre><code>
#!/bin/bash
# 定义与调用关联数组
declare -A data=(["name"]="Jiaqi Z.")
data["band"]="Roselia"
# 调用关联数组
echo "My name is ${data["name"]}, and I love ${data["band"]}."
                </code></pre>

                <p>在第3行，我们使用<code>declare -A</code>定义了一个“关联数组”，并在其中初始化了一个下标<sup>3</sup>为“name”的元素，其值为“Jiaqi Z.”。</p>

                <p>在第4行，我们又如同调用一般的数组一样，对其进行赋值（追加了一个新的键）。之后在第6行调用了这个数组，并如同一般调用下标那样调用这个数组的“键”从而获得对应的“值”。</p>

                <p>需要注意的是：在初始化定义时，需要特别指明元素的键（其基本格式如上面代码第3行那样），而在后续的使用中，则完全可将其视为特殊的数组使用（调用）</p>

                <p>与前面所介绍的获取数组所有元素类似，对于“关联数组”而言，我们也可以使用<code>&lt;变量名&gt;[*]</code>的方式获得其所有元素的值。只不过在这里仅输出所有“值”（不包括“键”）。如果希望输出所有“键”的元素，可以在前面加感叹号（如<code>!&lt;变量名&gt;[*]</code>）。例如，对于上面的代码，可以使用<code>echo ${data[*]}</code>的方式输出所有值，使用<code>echo ${!data[*]}</code>的方式输出所有“键”。</p>
            </div>

            <footer>
                <p>注解：</p>
                <ol>
                <li id="ftnt1">这里所说的“显式定义”，指的是在程序代码中直接写明数组变量的值</li>
                <li id="ftnt2">这一切是从C语言开始的。</li>
                <li id="ftnt3">在哈希结构中，我们通常称这个下标为“键”（key），而称这个数组的元素值为“值”（value）。</li>
                </ol>
            </footer>
        
        </div>

        

    </div>
</body>
</html>